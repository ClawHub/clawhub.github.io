<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JAVA线程池原理与源码分析 | ClawHub的技术分享</title><meta name="author" content="ClawHub"><meta name="copyright" content="ClawHub"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1、线程池常用接口介绍1.1、Executor123public interface Executor &amp;#123;void execute(Runnable command);&amp;#125; 执行提交的Runnable任务。其中的execute方法在将来的某个时候执行给定的任务，该任务可以在新线程、池化线程或调用线程中执行,具体由Executor的实现者决定。 1.2、ExecutorServic">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA线程池原理与源码分析">
<meta property="og:url" content="https://clawhub.github.io/2019/12/18/%E9%AB%98%E5%B9%B6%E5%8F%91/JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="ClawHub的技术分享">
<meta property="og:description" content="1、线程池常用接口介绍1.1、Executor123public interface Executor &amp;#123;void execute(Runnable command);&amp;#125; 执行提交的Runnable任务。其中的execute方法在将来的某个时候执行给定的任务，该任务可以在新线程、池化线程或调用线程中执行,具体由Executor的实现者决定。 1.2、ExecutorServic">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/top/19/11/27/b4a5ff53febcfefe69c91df73caad94f.jpg">
<meta property="article:published_time" content="2019-12-18T09:27:59.000Z">
<meta property="article:modified_time" content="2023-09-26T05:51:29.348Z">
<meta property="article:author" content="ClawHub">
<meta property="article:tag" content="高并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/top/19/11/27/b4a5ff53febcfefe69c91df73caad94f.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/clawhub/image/blog/favicon-32x32-clawhub.png"><link rel="canonical" href="https://clawhub.github.io/2019/12/18/%E9%AB%98%E5%B9%B6%E5%8F%91/JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"GOOBOT5XB8","apiKey":"68084d3bd15b2455050d3030780a5821","indexName":"clawhub-blog-search","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JAVA线程池原理与源码分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-26 13:51:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/clawhub/image/blog/avatar.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">331</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">35</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/top/19/11/27/b4a5ff53febcfefe69c91df73caad94f.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="ClawHub的技术分享"><span class="site-name">ClawHub的技术分享</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JAVA线程池原理与源码分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-12-18T09:27:59.000Z" title="发表于 2019-12-18 17:27:59">2019-12-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-26T05:51:29.348Z" title="更新于 2023-09-26 13:51:29">2023-09-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/">高并发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JAVA线程池原理与源码分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="1、线程池常用接口介绍"><a href="#1、线程池常用接口介绍" class="headerlink" title="1、线程池常用接口介绍"></a>1、线程池常用接口介绍</h3><h4 id="1-1、Executor"><a href="#1-1、Executor" class="headerlink" title="1.1、Executor"></a>1.1、Executor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行提交的Runnable任务。其中的execute方法在将来的某个时候执行给定的任务，该任务可以在新线程、池化线程或调用线程中执行,具体由Executor的实现者决定。</p>
<h4 id="1-2、ExecutorService"><a href="#1-2、ExecutorService" class="headerlink" title="1.2、ExecutorService"></a>1.2、ExecutorService</h4><p>ExecutorService继承自Executor，下面挑几个方法介绍：</p>
<h5 id="1-2-1、shutdown"><a href="#1-2-1、shutdown" class="headerlink" title="1.2.1、shutdown()"></a>1.2.1、shutdown()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>启动有序关闭线程池，在此过程中执行先前提交的任务，但不接受任何新任务。如果线程池已经关闭，调用此方法不会产生额外的效果。此方法不等待以前提交的任务完成执行,可以使用awaitTermination去实现。</p>
<h5 id="1-2-2、shutdownNow"><a href="#1-2-2、shutdownNow" class="headerlink" title="1.2.2、shutdownNow()"></a>1.2.2、shutdownNow()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>尝试停止所有正在积极执行的任务， 停止处理等待的任务，并返回等待执行的任务列表。 此方法不等待以前提交的任务完成执行,可以使用awaitTermination去实现。除了尽最大努力停止处理积极执行的任务外，没有任何保证。例如，典型的实现是：通过Thread#interrupt取消任务执行，但是任何未能响应中断的任务都可能永远不会终止。</p>
<h5 id="1-2-3、isShutdown"><a href="#1-2-3、isShutdown" class="headerlink" title="1.2.3、isShutdown()"></a>1.2.3、isShutdown()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>返回线程池关闭状态。</p>
<h5 id="1-2-4、isTerminated"><a href="#1-2-4、isTerminated" class="headerlink" title="1.2.4、isTerminated()"></a>1.2.4、isTerminated()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>如果关闭后所有任务都已完成，则返回 true。注意，除非首先调用了shutdown或shutdownNow，否则isTerminated永远不会返回true。</p>
<h5 id="1-2-5、awaitTermination-long-timeout-TimeUnit-unit"><a href="#1-2-5、awaitTermination-long-timeout-TimeUnit-unit" class="headerlink" title="1.2.5、awaitTermination(long timeout, TimeUnit unit)"></a>1.2.5、awaitTermination(long timeout, TimeUnit unit)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>
<p>线程阻塞阻塞，直到所有任务都在shutdown请求之后执行完毕，或者超时发生，或者当前线程被中断(以先发生的情况为准)。</p>
<h5 id="1-2-6、submit"><a href="#1-2-6、submit" class="headerlink" title="1.2.6、submit"></a>1.2.6、submit</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br></pre></td></tr></table></figure>
<p>提交一个value-returning任务以执行，并返回一个表示该任务未决结果的Future。 Future的 get方法将在成功完成任务后返回任务的结果。</p>
<h4 id="1-3、ScheduledExecutorService"><a href="#1-3、ScheduledExecutorService" class="headerlink" title="1.3、ScheduledExecutorService"></a>1.3、ScheduledExecutorService</h4><p>安排命令在给定的延迟之后运行，或者定期执行,继承自ExecutorService接口由以下四个方法组成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在给定延迟之后启动任务，返回ScheduledFuture</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<span class="type">long</span> delay, TimeUnit unit);</span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="title function_">schedule</span><span class="params">(Callable&lt;V&gt; callable,<span class="type">long</span> delay, TimeUnit unit)</span>;</span><br><span class="line"><span class="comment">//创建并执行一个周期性操作，该操作在给定的初始延迟之后首次启动，然后在给定的周期内执行;</span></span><br><span class="line"><span class="comment">//如果任务的任何执行遇到异常，则禁止后续执行。否则，任务只会通过执行器的取消或终止而终止。</span></span><br><span class="line"><span class="comment">//如果此任务的任何执行时间超过其周期，则后续执行可能会延迟开始，但不会并发执行。</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<span class="type">long</span> initialDelay,<span class="type">long</span> period,TimeUnit unit);</span><br><span class="line"><span class="comment">//创建并执行一个周期性操作，该操作在给定的初始延迟之后首次启动，然后在一次执行的终止和下一次执行的开始之间使用给定的延迟。</span></span><br><span class="line"><span class="comment">//如果任务的任何执行遇到异常，则禁止后续执行。否则，任务只会通过执行器的取消或终止而终止。</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<span class="type">long</span> initialDelay,<span class="type">long</span> delay,TimeUnit unit);</span><br></pre></td></tr></table></figure>
<h4 id="1-4、ThreadFactory"><a href="#1-4、ThreadFactory" class="headerlink" title="1.4、ThreadFactory"></a>1.4、ThreadFactory</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按需创建新线程的对象。</p>
<h4 id="1-5、Callable"><a href="#1-5、Callable" class="headerlink" title="1.5、Callable"></a>1.5、Callable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回任务结果也可能抛出异常。</p>
<h4 id="1-6、Future"><a href="#1-6、Future" class="headerlink" title="1.6、Future"></a>1.6、Future</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span><span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br></pre></td></tr></table></figure>
<p>Future表示异步计算的结果。方法用于检查计算是否完成，等待计算完成并检索计算结果。只有当计算完成时，才可以使用方法get检索结果，如果需要，可以阻塞，直到准备好为止。取消由cancel方法执行。还提供了其他方法来确定任务是否正常完成或被取消。一旦计算完成，就不能取消计算。</p>
<h4 id="1-7、Delayed"><a href="#1-7、Delayed" class="headerlink" title="1.7、Delayed"></a>1.7、Delayed</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Delayed</span> <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Delayed&gt; &#123;</span><br><span class="line">    <span class="comment">//在给定的时间单位中返回与此对象关联的剩余延迟</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">getDelay</span><span class="params">(TimeUnit unit)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种混合风格的接口，用于标记在给定延迟之后应该执行的对象。</p>
<h4 id="1-8、ScheduledFuture"><a href="#1-8、ScheduledFuture" class="headerlink" title="1.8、ScheduledFuture"></a>1.8、ScheduledFuture</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ScheduledFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Delayed</span>, Future&lt;V&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、线程池工作流程"><a href="#2、线程池工作流程" class="headerlink" title="2、线程池工作流程"></a>2、线程池工作流程</h3><p><img src="https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/blog/19/12/17/8bfc8c8735aa9823b66fdbc8cfd4f130.jpg" alt="线程池的主要工作流程.jpg"></p>
<p>新任务进来时：</p>
<ol>
<li>如果当前运行的线程少于corePoolSize，则创建新线程（核心线程）来执行任务。</li>
<li>如果运行的线程等于或多于corePoolSize ,则将任务加入BlockingQueue。</li>
<li>如果BlockingQueue队列已满，则创建新的线程（非核心）来处理任务。</li>
<li>如果核心线程与非核心线程总数超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler拒绝策略。</li>
</ol>
<h3 id="3、ThreadPoolExecutor介绍"><a href="#3、ThreadPoolExecutor介绍" class="headerlink" title="3、ThreadPoolExecutor介绍"></a>3、ThreadPoolExecutor介绍</h3><p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="type">int</span> corePoolSize,<span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params"><span class="type">long</span> keepAliveTime,TimeUnit unit,</span></span><br><span class="line"><span class="params">BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>corePoolSize<br>除非设置了 allowCoreThreadTimeOut，否则要保留在线程池中的线程数（即使它们是空闲的）。</li>
<li>maximumPoolSize<br>线程池中允许的最大线程数。</li>
<li>keepAliveTime<br>当线程数大于corePoolSize时，这是多余的空闲线程在终止新任务之前等待新任务的最长时间。</li>
<li>unit<br>keepAliveTime参数的时间单位。</li>
<li>workQueue<br>用于在任务执行前保存任务的队列。这个队列只包含execute方法提交的Runnable任务。</li>
<li>threadFactory<br>执行程序创建新线程时使用的工厂。</li>
<li>handler<br>由于达到线程边界和队列容量而阻塞执行时使用的处理程序。</li>
</ul>
<h4 id="3-1、BlockingQueue"><a href="#3-1、BlockingQueue" class="headerlink" title="3.1、BlockingQueue"></a>3.1、BlockingQueue</h4><ul>
<li>SynchronousQueue<br>不存储元素的阻塞队列，一个插入操作，必须等待移除操作结束，每个任务一个线程。使用的时候maximumPoolSize一般指定成Integer.MAX_VALUE。</li>
<li>LinkedBlockingQueue<br>如果当前线程数大于等于核心线程数，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中。</li>
<li>ArrayBlockingQueue<br>可以限定队列的长度，接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则执行拒绝策略。</li>
<li>DelayQueue<br>队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务。</li>
<li>priorityBlockingQuene<br>具有优先级的无界阻塞队列。</li>
</ul>
<h4 id="3-2、RejectedExecutionHandler"><a href="#3-2、RejectedExecutionHandler" class="headerlink" title="3.2、RejectedExecutionHandler"></a>3.2、RejectedExecutionHandler</h4><p>有4个ThreeadPoolExecutor内部类。</p>
<ul>
<li>AbortPolicy<br>直接抛出异常，默认策略。</li>
<li>CallerRunsPolicy<br>用调用者所在的线程来执行任务。</li>
<li>DiscardOldestPolicy<br>丢弃阻塞队列中靠最前的任务，并执行当前任务。</li>
<li>DiscardPolicy<br>直接丢弃任务。</li>
</ul>
<p>最好自定义饱和策略，实现RejectedExecutionHandler接口,如:记录日志或持久化存储不能处理的任务。</p>
<h4 id="3-3、线程池大小设置"><a href="#3-3、线程池大小设置" class="headerlink" title="3.3、线程池大小设置"></a>3.3、线程池大小设置</h4><ul>
<li>CPU密集型<br>尽量使用较小的线程池，减少CUP上下文切换，一般设置为CPU核心数+1。</li>
<li>IO密集型<br>可以适当加大线程池数量，IO多，所以在等待IO的时候，充分利用CPU,一般设置为CPU核心数2倍。<br>但是对于一些特别耗时的IO操作，盲目的用线程池可能也不是很好，通过异步+单线程轮询，上层再配合上一个固定的线程池，效果可能更好，参考Reactor模型。</li>
<li>混合型<br>视具体情况而定。</li>
</ul>
<h4 id="3-4、任务提交"><a href="#3-4、任务提交" class="headerlink" title="3.4、任务提交"></a>3.4、任务提交</h4><ul>
<li>Callable<br>通过submit函数提交，返回Future对象。</li>
<li>Runnable<br>通过execute提交，没有返回结果。</li>
</ul>
<h4 id="3-5、关闭线程池"><a href="#3-5、关闭线程池" class="headerlink" title="3.5、关闭线程池"></a>3.5、关闭线程池</h4><ul>
<li>shutdown()<br>仅停止阻塞队列中等待的线程，那些正在执行的线程就会让他们执行结束。</li>
<li>shutdownNow()<br>不仅会停止阻塞队列中的线程，而且会停止正在执行的线程。</li>
</ul>
<h3 id="4、线程池实现原理"><a href="#4、线程池实现原理" class="headerlink" title="4、线程池实现原理"></a>4、线程池实现原理</h3><h4 id="4-1、-线程池状态"><a href="#4-1、-线程池状态" class="headerlink" title="4.1、 线程池状态"></a>4.1、 线程池状态</h4><p>线程池的内部状态由AtomicInteger修饰的ctl表示，其高3位表示线程池的运行状态，低29位表示线程池中的线程数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>主池控制状态ctl是一个原子整数，包含两个概念字段:</p>
<ul>
<li>workerCount：指示有效线程数。</li>
<li>runState：指示是否运行、关闭等。</li>
</ul>
<p>为了将这两个字段打包成一个整型，所以将workerCount限制为(2^29)-1个线程，而不是(2^31)-1个线程。</p>
<p>workerCount是工作线程数量。该值可能与实际活动线程的数量存在暂时性差异，例如，当ThreadFactory在被请求时无法创建线程，以及退出的线程在终止前仍在执行bookkeeping时。 用户可见的池大小报告为工作线程集的当前大小。</p>
<p>runState提供了生命周期，具有以下值:</p>
<ul>
<li>RUNNING:接受新任务并处理排队的任务</li>
<li>SHUTDOWN:不接受新任务，而是处理队列的任务。</li>
<li>STOP:不接受新任务，不处理队列的任务，中断正在进行的任务。</li>
<li>TIDYING:所有任务都已终止，workerCount为零，过渡到状态TIDYING的线程将运行terminated()钩子方法。</li>
<li>TERMINATED:terminated()方法执行完毕。</li>
</ul>
<p>为了允许有序比较，这些值之间的数值顺序很重要。运行状态会随着时间单调地增加，但不需要达到每个状态。转换:<br><img src="https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/blog/19/12/18/9f4cc8fdf7eb6fb1ff4f8804658079a5.jpg" alt="线程池内部状态转换图.png"></p>
<ul>
<li>RUNNING -&gt; SHUTDOWN<br>在调用shutdown()时，可以隐式地在finalize()中调用。</li>
<li>(RUNNING or SHUTDOWN) -&gt; STOP<br>调用shutdownNow()。</li>
<li>SHUTDOWN -&gt; TIDYING<br>当队列和池都为空时。</li>
<li>STOP -&gt; TIDYING<br>当池是空的时候。</li>
<li>TIDYING -&gt; TERMINATED<br>当terminated()钩子方法完成时。</li>
</ul>
<p>当状态达到TERMINATED时，在awaitTermination()中等待的线程将返回。</p>
<p>下面看以下其他状态信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer.SIZE为32，COUNT_BITS为29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">//2^29-1 最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 即高3位为111，该状态的线程池会接收新任务，并处理阻塞队列中的任务；</span></span><br><span class="line"><span class="comment">* 111 0 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment">* -1 原码：0000 ... 0001 反码：1111 ... 1110 补码：1111 ... 1111</span></span><br><span class="line"><span class="comment">* 左移操作：后面补 0</span></span><br><span class="line"><span class="comment">* 111 0 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span> <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 即高3位为000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</span></span><br><span class="line"><span class="comment">* 000 0 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span> <span class="operator">=</span> <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 即高3位为001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在* 运行的任务；</span></span><br><span class="line"><span class="comment">* 001 0 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 即高3位为010，所有任务都已终止，workerCount为零，过渡到状态TIDYING的线程将运行terminated()钩子方法；</span></span><br><span class="line"><span class="comment">* 010 0 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span> <span class="operator">=</span> <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 即高3位为011，terminated()方法执行完毕；</span></span><br><span class="line"><span class="comment">* 011 0 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span> <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//根据ctl计算runState</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line"><span class="comment">//2^29   =  001 0 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment">//2^29-1 =  000 1 1111 1111 1111 1111 1111 1111 1111</span></span><br><span class="line"><span class="comment">//~(2^29-1)=111 0 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment">//假设c为 STOP 001 0 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment">// 最终值：    001 0 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line">    <span class="keyword">return</span> c &amp; ~CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据ctl计算 workerCount</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line"><span class="comment">//2^29-1 =  000 1 1111 1111 1111 1111 1111 1111 1111</span></span><br><span class="line"><span class="comment">//假设c =   000 0 0000 0000 0000 0000 0000 0000 0001  1个线程</span></span><br><span class="line"><span class="comment">//最终值：  000 0 0000 0000 0000 0000 0000 0000 0001  1</span></span><br><span class="line">    <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据runState和workerCount计算ctl</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123;</span><br><span class="line"><span class="comment">//假设 rs: STOP  001 0 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment">//假设 wc:       000 0 0000 0000 0000 0000 0000 0000 0001  1个线程</span></span><br><span class="line"><span class="comment">//最终值：       001 0 0000 0000 0000 0000 0000 0000 0001</span></span><br><span class="line">    <span class="keyword">return</span> rs | wc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateLessThan</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateAtLeast</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RUNNING状态为负数，肯定小于SHUTDOWN，返回线程池是否为运行状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//试图增加ctl的workerCount字段值。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compareAndIncrementWorkerCount</span><span class="params">(<span class="type">int</span> expect)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尝试减少ctl的workerCount字段值。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compareAndDecrementWorkerCount</span><span class="params">(<span class="type">int</span> expect)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递减ctl的workerCount字段。这只在线程突然终止时调用(请参阅processWorkerExit)。在getTask中执行其他递减。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">decrementWorkerCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndDecrementWorkerCount(ctl.get()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Doug Lea大神的设计啊，感觉计算机的基础真的是数学。</p>
<h4 id="4-2、-内部类Worker"><a href="#4-2、-内部类Worker" class="headerlink" title="4.2、 内部类Worker"></a>4.2、 内部类Worker</h4><p>Worker继承了AbstractQueuedSynchronizer，并且实现了Runnable接口。<br>维护了以下三个变量，其中completedTasks由volatile修饰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//线程这个工作程序正在运行。如果工厂失败，则为空。</span></span><br><span class="line"><span class="keyword">final</span> Thread thread;</span><br><span class="line"><span class="comment">//要运行的初始任务。可能是null。</span></span><br><span class="line">Runnable firstTask;</span><br><span class="line"><span class="comment">//线程任务计数器</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br></pre></td></tr></table></figure>
<p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用ThreadFactory中给定的第一个任务和线程创建。</span></span><br><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">    <span class="comment">//禁止中断，直到运行工作程序</span></span><br><span class="line">    setState(-<span class="number">1</span>); </span><br><span class="line">    <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然实现了Runnable接口，必然实现run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Delegates main run loop to outer runWorker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//核心</span></span><br><span class="line">    runWorker(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3、runWorker-Worker-w-执行任务"><a href="#4-3、runWorker-Worker-w-执行任务" class="headerlink" title="4.3、runWorker(Worker w)执行任务"></a>4.3、runWorker(Worker w)执行任务</h4><p>先看一眼执行流程图，再看源码，会更清晰一点：<br><img src="https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/blog/19/12/18/725628e9a3ceeb0eb9bcc1fc4c9ec912.jpg" alt="runWorker.png"></p>
<p>首先来看runWorker(Worker w)源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取第一个任务</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    <span class="comment">//第一个任务位置置空</span></span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//因为Worker实现了AQS，此处是释放锁，new Worker()是state==-1，此处是调用Worker类的 release(1)方法，将state置为0。Worker中interruptIfStarted()中只有state&gt;=0才允许调用中断</span></span><br><span class="line">    w.unlock();</span><br><span class="line">    <span class="comment">//是否突然完成，如果是由于异常导致的进入finally，那么completedAbruptly==true就是突然完成的</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//先处理firstTask，之后依次处理其他任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//获取锁</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">//如果池停止，确保线程被中断;如果没有，请确保线程没有中断。这需要在第二种情况下重新检查，以处理清除中断时的shutdownNow竞争</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//自定义实现</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x;</span><br><span class="line">                    <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x;</span><br><span class="line">                    <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//自定义实现</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//任务完成数+1</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//Worker的结束后的处理工作</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面再来看上述源码中的getTask()与processWorkerExit(w, completedAbruptly)方法：</p>
<h5 id="4-3-1、getTask"><a href="#4-3-1、getTask" class="headerlink" title="4.3.1、getTask()"></a>4.3.1、getTask()</h5><p>根据当前配置设置执行阻塞或定时等待任务，或者如果该worker因为任何原因必须退出，则返回null,在这种情况下workerCount将递减。</p>
<p>返回空的情况：</p>
<ol>
<li>大于 maximumPoolSize 个 workers(由于调用setMaximumPoolSize)</li>
<li>线程池关闭</li>
<li>线程池关闭了并且队列为空</li>
<li>这个worker超时等待任务，超时的worker在超时等待之前和之后都可能终止(即allowCoreThreadTimeOut || workerCount &gt; corePoolSize)，如果队列不是空的，那么这个worker不是池中的最后一个线程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="comment">//获取线程池状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line">        <span class="comment">//仅在必要时检查队列是否为空。</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">//递减ctl的workerCount字段</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取workerCount数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        <span class="comment">//线程超时控制</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">//尝试减少ctl的workerCount字段</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果有超时控制，则使用带超时时间的poll，否则使用take,没有任务的时候一直阻塞，这两个方法都会抛出InterruptedException</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?workQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS) :workQueue.take();</span><br><span class="line">            <span class="comment">//有任务就返回</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">//获取任务超时，肯定是走了poll逻辑</span></span><br><span class="line">            timedOut = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">//被中断</span></span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-3-1、processWorkerExit-Worker-w-boolean-completedAbruptly"><a href="#4-3-1、processWorkerExit-Worker-w-boolean-completedAbruptly" class="headerlink" title="4.3.1、processWorkerExit(Worker w, boolean completedAbruptly)"></a>4.3.1、processWorkerExit(Worker w, boolean completedAbruptly)</h5><p>为垂死的worker进行清理和bookkeeping。仅从工作线程调用。除非completedAbruptly被设置，否则假定workerCount已经被调整以考虑退出。此方法从工作集中移除线程，如果线程池由于用户任务异常而退出，或者运行的工作池小于corePoolSize，或者队列非空但没有工作池， 则可能终止线程池或替换工作池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> &#123;</span><br><span class="line">    <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">    <span class="comment">// true：用户线程运行异常,需要扣减</span></span><br><span class="line">    <span class="comment">// false：getTask方法中扣减线程数量</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly)</span><br><span class="line">        <span class="comment">//递减ctl的workerCount字段。</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">    <span class="comment">//获取主锁，锁定</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//更新完成任务计数器</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">//移除worker</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有worker线程移除，可能是最后一个线程退出需要尝试终止线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">// 如果线程为running或shutdown状态，即tryTerminate()没有成功终止线程池，则判断是否有必要一个worker</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="comment">// 正常退出，计算min：需要维护的最小线程数量</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="comment">// allowCoreThreadTimeOut 默认false：是否需要维持核心线程的数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="comment">// 如果min ==0 或者workerQueue为空，min = 1</span></span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; !workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果线程数量大于最少数量min，直接返回，不需要新增线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加一个没有firstTask的worker</span></span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4、任务提交"><a href="#4-4、任务提交" class="headerlink" title="4.4、任务提交"></a>4.4、任务提交</h4><p>提交有两种：</p>
<ul>
<li>Executor#execute(Runnable command)<br>Executor接口提供的方法，在将来的某个时候执行给定的命令.该命令可以在新线程、池化线程或调用线程中执行,具体由Executor的实现者决定。</li>
<li>ExecutorService#submit(Callable<T> task)<br>提交一个value-returning任务以执行，并返回一个表示该任务未决结果的Future。Future的get方法将在成功完成任务后返回任务的结果。</li>
</ul>
<h4 id="4-5、任务执行"><a href="#4-5、任务执行" class="headerlink" title="4.5、任务执行"></a>4.5、任务执行</h4><h5 id="4-5-1、-execute-Runnable-command"><a href="#4-5-1、-execute-Runnable-command" class="headerlink" title="4.5.1、 execute(Runnable command)"></a>4.5.1、 execute(Runnable command)</h5><p>任务执行流程图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/blog/19/12/18/4ec0ccf4c05ce841afc49a20d9486800.jpg" alt="execute.png"></p>
<p>三步处理：</p>
<ol>
<li>如果运行的线程小于corePoolSize，则尝试用给定的命令作为第一个任务启动一个新线程。对addWorker的调用原子性地检查runState和workerCount，因此可以通过返回false来防止错误警报，因为错误警报会在不应该添加线程的时候添加线程。</li>
<li>如果一个任务可以成功排队，那么我们仍然需要再次检查是否应该添加一个线程 (因为自上次检查以来已有的线程已经死亡)，或者池在进入这个方法后关闭。因此，我们重新检查状态，如果必要的话，如果停止，则回滚队列;如果没有，则启动一个新线程。</li>
<li>如果无法对任务排队，则尝试添加新线程。 如果它失败了，我们知道pool被关闭或饱和，所以拒绝任务。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="comment">//任务为空，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">   <span class="comment">//获取线程控制字段的值</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">   <span class="comment">//如果当前工作线程数量少于corePoolSize（核心线程数）</span></span><br><span class="line">   <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">       <span class="comment">//创建新的线程并执行任务，如果成功就返回</span></span><br><span class="line">       <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">       <span class="comment">//上一步失败，重新获取ctl</span></span><br><span class="line">       c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果线城池正在运行，且入队成功</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">//重新获取ctl</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">//如果线程没有运行且删除任务成功</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">//拒绝任务</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//如果当前的工作线程数量为0，只要还有活动的worker线程，就可以消费workerQueue中的任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//第一个参数为null，说明只为新建一个worker线程，没有指定firstTask</span></span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">    <span class="comment">//如果线程池不是running状态 或者 无法入队列,尝试开启新线程，扩容至maxPoolSize，如果addWork(command, false)失败了，拒绝当前command</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面详细看一下上述代码中出现的方法：addWorker(Runnable firstTask, boolean core)。</p>
<h6 id="4-5-1-1、addWorker-Runnable-firstTask-boolean-core"><a href="#4-5-1-1、addWorker-Runnable-firstTask-boolean-core" class="headerlink" title="4.5.1.1、addWorker(Runnable firstTask, boolean core)"></a>4.5.1.1、addWorker(Runnable firstTask, boolean core)</h6><p><img src="https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/blog/19/12/18/d26dbf0a827255bf1e64092cb02c094f.jpg" alt="addWorker.jpg"></p>
<p>检查是否可以根据当前池状态和给定的界限(核心或最大值)添加新worker，如果是这样，worker计数将相应地进行调整，如果可能，将创建并启动一个新worker， 并将运行firstTask作为其第一个任务。 如果池已停止或有资格关闭，则此方法返回false。如果线程工厂在被请求时没有创建线程，则返回false。如果线程创建失败，要么是由于线程工厂返回null，要么是由于异常 (通常是Thread.start()中的OutOfMemoryError))，我们将回滚。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    <span class="comment">//好久没见过这种写法了</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">//线程池状态与工作线程数量处理,worker数量+1</span></span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="comment">//获取当前线程池状态与线程数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">//获取当前线程池状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line">        <span class="comment">// 仅在必要时检查队列是否为空。如果池子处于SHUTDOWN，STOP，TIDYING，TERMINATED的时候 不处理提交的任务,判断线程池是否可以添加worker线程</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span> &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//线程池处于工作状态</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="comment">//获取工作线程数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">            <span class="comment">//如果线程数量超过最大值或者超过corePoolSize或者超过maximumPoolSize 拒绝执行任务</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//试图增加ctl的workerCount字段</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="comment">//中断外层循环</span></span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// Re-read ctl</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">            <span class="comment">//如果当前线程池状态已经改变</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="comment">//继续外层循环</span></span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">//否则CAS因workerCount更改而失败;重试内循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加到worker线程集合，并启动线程,工作线程状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//继承AQS并实现了Runnable接口</span></span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//将任务封装</span></span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="comment">//获取当前线程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//获取全局锁</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            <span class="comment">//全局锁定</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//持锁时重新检查。退出ThreadFactory故障，或者在获取锁之前关闭。</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">//如果当前线程池关闭了</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                   <span class="comment">//测试该线程是否活动。如果线程已经启动并且还没有死，那么它就是活的。                                       </span></span><br><span class="line">                   <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                   <span class="comment">//入工作线程池</span></span><br><span class="line">                   workers.add(w);</span><br><span class="line">                   <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                   <span class="comment">//跟踪最大的池大小</span></span><br><span class="line">                   <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                   <span class="comment">//状态</span></span><br><span class="line">                   workerAdded = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果工作线程加入成功，开始线程的执行，并设置状态</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//判断工作线程是否启动成功</span></span><br><span class="line">        <span class="keyword">if</span> (!workerStarted)</span><br><span class="line">            <span class="comment">//回滚工作线程创建</span></span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回工作线程状态</span></span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再分析回滚工作线程创建逻辑方法：addWorkerFailed(w)。<br>回滚工作线程创建,如果存在，则从worker中移除worker, 递减ctl的workerCount字段。,重新检查终止，以防这个worker的存在导致终止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addWorkerFailed</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="comment">//获取全局锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果存在，则从worker中移除worker</span></span><br><span class="line">        <span class="keyword">if</span> (w != <span class="literal">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        <span class="comment">//递减ctl的workerCount字段。</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        <span class="comment">//重新检查终止</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的tryTerminate()方法：<br>如果是SHUTDOWN或者STOP 且池子为空，转为TERMINATED状态。如果有条件终止，但是workerCount不为零，则中断空闲worker，以确保关机信号传播。必须在任何可能使终止成为可能的操作之后调用此方法–在关机期间减少worker数量或从队列中删除任务。该方法是非私有的，允许从ScheduledThreadPoolExecutor访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryTerminate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">//如果线程池处于运行中，或者阻塞队列中仍有任务，返回</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//还有工作线程</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//中断空闲工作线程</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取全局锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//设置ctl状态TIDYING</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//方法在执行程序终止时调用，默认什么都不执行</span></span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//完成terminated()方法，状态为TERMINATED</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    <span class="comment">//唤醒所有等待条件的节点</span></span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法在执行程序终止时调用,默认什么都不执行</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">terminated</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-5-1-2、-reject-Runnable-command-拒绝策略"><a href="#4-5-1-2、-reject-Runnable-command-拒绝策略" class="headerlink" title="4.5.1.2、 reject(Runnable command)拒绝策略"></a>4.5.1.2、 reject(Runnable command)拒绝策略</h4><p>为给定的命令调用被拒绝的执行处理程序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    handler.rejectedExecution(command, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/important/19/12/01/ee4798cfcd4d069d07aa0acbbc106ae6.jpg" alt="tencent.jpg"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://clawhub.github.io">ClawHub</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://clawhub.github.io/2019/12/18/%E9%AB%98%E5%B9%B6%E5%8F%91/JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">https://clawhub.github.io/2019/12/18/%E9%AB%98%E5%B9%B6%E5%8F%91/JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://clawhub.github.io" target="_blank">ClawHub的技术分享</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/">高并发</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/top/19/11/27/b4a5ff53febcfefe69c91df73caad94f.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/12/18/%E9%AB%98%E5%B9%B6%E5%8F%91/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%B9%8BLinkedBlockingQueue%E5%88%86%E6%9E%90/" title="阻塞队列之LinkedBlockingQueue分析"><img class="cover" src="https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/top/19/11/27/2e914990e5a78473a36aa49d69399ef0.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">阻塞队列之LinkedBlockingQueue分析</div></div></a></div><div class="next-post pull-right"><a href="/2019/12/18/LeetCode/234.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/" title="LeetCode|234.回文链表"><img class="cover" src="https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/top/19/11/27/d41d04ee62d513b39fc79eb4b77c3f59.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">LeetCode|234.回文链表</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/12/10/%E9%AB%98%E5%B9%B6%E5%8F%91/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90/" title="JAVA内存模型分析"><img class="cover" src="https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/top/19/11/27/2857b5cbaf30313e54ee14e5c1bedfc1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-10</div><div class="title">JAVA内存模型分析</div></div></a></div><div><a href="/2019/12/10/%E9%AB%98%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%8C%91%E6%88%98%EF%BC%9A%E6%AD%BB%E9%94%81%E4%B8%8E%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/" title="并发编程挑战：死锁与上下文切换"><img class="cover" src="https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/top/19/11/27/3b653a1acb549bf2a00131876c154534.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-10</div><div class="title">并发编程挑战：死锁与上下文切换</div></div></a></div><div><a href="/2019/12/18/%E9%AB%98%E5%B9%B6%E5%8F%91/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%B9%8BLinkedBlockingQueue%E5%88%86%E6%9E%90/" title="阻塞队列之LinkedBlockingQueue分析"><img class="cover" src="https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/top/19/11/27/2e914990e5a78473a36aa49d69399ef0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-18</div><div class="title">阻塞队列之LinkedBlockingQueue分析</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/clawhub/image/blog/avatar.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ClawHub</div><div class="author-info__description">ClawHub的技术分享，记录学习中的点点滴滴！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">331</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">35</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/clawhub" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:clawhub@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D"><span class="toc-text">1、线程池常用接口介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E3%80%81Executor"><span class="toc-text">1.1、Executor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%E3%80%81ExecutorService"><span class="toc-text">1.2、ExecutorService</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-1%E3%80%81shutdown"><span class="toc-text">1.2.1、shutdown()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2%E3%80%81shutdownNow"><span class="toc-text">1.2.2、shutdownNow()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3%E3%80%81isShutdown"><span class="toc-text">1.2.3、isShutdown()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-4%E3%80%81isTerminated"><span class="toc-text">1.2.4、isTerminated()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-5%E3%80%81awaitTermination-long-timeout-TimeUnit-unit"><span class="toc-text">1.2.5、awaitTermination(long timeout, TimeUnit unit)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-6%E3%80%81submit"><span class="toc-text">1.2.6、submit</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3%E3%80%81ScheduledExecutorService"><span class="toc-text">1.3、ScheduledExecutorService</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4%E3%80%81ThreadFactory"><span class="toc-text">1.4、ThreadFactory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5%E3%80%81Callable"><span class="toc-text">1.5、Callable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6%E3%80%81Future"><span class="toc-text">1.6、Future</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7%E3%80%81Delayed"><span class="toc-text">1.7、Delayed</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8%E3%80%81ScheduledFuture"><span class="toc-text">1.8、ScheduledFuture</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">2、线程池工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81ThreadPoolExecutor%E4%BB%8B%E7%BB%8D"><span class="toc-text">3、ThreadPoolExecutor介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1%E3%80%81BlockingQueue"><span class="toc-text">3.1、BlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E3%80%81RejectedExecutionHandler"><span class="toc-text">3.2、RejectedExecutionHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%A7%E5%B0%8F%E8%AE%BE%E7%BD%AE"><span class="toc-text">3.3、线程池大小设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4%E3%80%81%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4"><span class="toc-text">3.4、任务提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5%E3%80%81%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">3.5、关闭线程池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">4、线程池实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1%E3%80%81-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81"><span class="toc-text">4.1、 线程池状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2%E3%80%81-%E5%86%85%E9%83%A8%E7%B1%BBWorker"><span class="toc-text">4.2、 内部类Worker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3%E3%80%81runWorker-Worker-w-%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1"><span class="toc-text">4.3、runWorker(Worker w)执行任务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1%E3%80%81getTask"><span class="toc-text">4.3.1、getTask()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1%E3%80%81processWorkerExit-Worker-w-boolean-completedAbruptly"><span class="toc-text">4.3.1、processWorkerExit(Worker w, boolean completedAbruptly)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4%E3%80%81%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4"><span class="toc-text">4.4、任务提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5%E3%80%81%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C"><span class="toc-text">4.5、任务执行</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-1%E3%80%81-execute-Runnable-command"><span class="toc-text">4.5.1、 execute(Runnable command)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#4-5-1-1%E3%80%81addWorker-Runnable-firstTask-boolean-core"><span class="toc-text">4.5.1.1、addWorker(Runnable firstTask, boolean core)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-2%E3%80%81-reject-Runnable-command-%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-text">4.5.1.2、 reject(Runnable command)拒绝策略</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/09/20/%E9%9A%8F%E7%AC%94/2023%E9%87%8D%E6%95%B4%E5%BE%85%E5%8F%91/" title="2023重整待发"><img src="https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/top/19/11/27/04cde2146d3d116bc3a2cea0a22d8138.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2023重整待发"/></a><div class="content"><a class="title" href="/2023/09/20/%E9%9A%8F%E7%AC%94/2023%E9%87%8D%E6%95%B4%E5%BE%85%E5%8F%91/" title="2023重整待发">2023重整待发</a><time datetime="2023-09-20T14:02:59.000Z" title="发表于 2023-09-20 22:02:59">2023-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E9%98%BF%E9%87%8CAPI%E7%BD%91%E5%85%B3%E4%B8%8EDubbo%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8/" title="阿里API网关与Dubbo泛化调用"><img src="https://cdn.jsdelivr.net/gh/ClawHub/image/image/photo-1677746792119-d8f8ee8e77f5%3Fcrop%3Dentropy%26cs%3Dtinysrgb%26fit%3Dcrop%26fm%3Djpg%26h%3D900%26ixid%3DMnwxfDB8MXxyYW5kb218MHxjb2xsZWN0aW9uaWR8fHx8fHx8MTY5NTc5ODc0Nw%26ixlib%3Drb-4.0.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="阿里API网关与Dubbo泛化调用"/></a><div class="content"><a class="title" href="/2022/05/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E9%98%BF%E9%87%8CAPI%E7%BD%91%E5%85%B3%E4%B8%8EDubbo%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8/" title="阿里API网关与Dubbo泛化调用">阿里API网关与Dubbo泛化调用</a><time datetime="2022-05-21T13:45:42.000Z" title="发表于 2022-05-21 21:45:42">2022-05-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/02/21/%E8%B5%84%E6%BA%90%E6%90%9C%E9%9B%86/%E6%9E%B6%E6%9E%84%E6%96%87%E7%AB%A0%E6%90%9C%E9%9B%86/" title="架构文章搜集"><img src="https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/top/19/11/27/bfff056d1e8ca0e9ba91286143e7989d.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="架构文章搜集"/></a><div class="content"><a class="title" href="/2020/02/21/%E8%B5%84%E6%BA%90%E6%90%9C%E9%9B%86/%E6%9E%B6%E6%9E%84%E6%96%87%E7%AB%A0%E6%90%9C%E9%9B%86/" title="架构文章搜集">架构文章搜集</a><time datetime="2020-02-21T03:20:59.000Z" title="发表于 2020-02-21 11:20:59">2020-02-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/01/20/%E9%9A%8F%E7%AC%94/%E9%98%BF%E9%87%8CCCO%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95%E7%9A%84%E6%80%9D%E8%80%83/" title="阿里CCO项目组面试的思考"><img src="https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/top/19/11/27/04cde2146d3d116bc3a2cea0a22d8138.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="阿里CCO项目组面试的思考"/></a><div class="content"><a class="title" href="/2020/01/20/%E9%9A%8F%E7%AC%94/%E9%98%BF%E9%87%8CCCO%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95%E7%9A%84%E6%80%9D%E8%80%83/" title="阿里CCO项目组面试的思考">阿里CCO项目组面试的思考</a><time datetime="2020-01-20T14:02:59.000Z" title="发表于 2020-01-20 22:02:59">2020-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/01/19/%E9%9D%A2%E8%AF%95/%E9%98%BF%E9%87%8CJava%E5%90%8E%E7%AB%AF%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/" title="阿里Java后端在线笔试题及答案"><img src="https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/top/19/11/27/36d28ae9e40c127e700c673778a902e0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="阿里Java后端在线笔试题及答案"/></a><div class="content"><a class="title" href="/2020/01/19/%E9%9D%A2%E8%AF%95/%E9%98%BF%E9%87%8CJava%E5%90%8E%E7%AB%AF%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/" title="阿里Java后端在线笔试题及答案">阿里Java后端在线笔试题及答案</a><time datetime="2020-01-19T03:33:59.000Z" title="发表于 2020-01-19 11:33:59">2020-01-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2023 By ClawHub</div><div class="footer_custom_text">好好学习 天天向上</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div></body></html>