<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JAVA并发容器源码分析【二】ConcurrentHashMap源码翻译之类注释与综述部分 | ClawHub的技术分享</title><meta name="author" content="ClawHub"><meta name="copyright" content="ClawHub"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JDK8源码，ConcurrentHashMap的类注释与综述部分： 类注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA并发容器源码分析【二】ConcurrentHashMap源码翻译之类注释与综述部分">
<meta property="og:url" content="https://clawhub.github.io/2019/08/06/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90%E4%BA%8C%E3%80%91ConcurrentHashMap%E6%BA%90%E7%A0%81%E7%BF%BB%E8%AF%91%E4%B9%8B%E7%B1%BB%E6%B3%A8%E9%87%8A%E4%B8%8E%E7%BB%BC%E8%BF%B0%E9%83%A8%E5%88%86/index.html">
<meta property="og:site_name" content="ClawHub的技术分享">
<meta property="og:description" content="JDK8源码，ConcurrentHashMap的类注释与综述部分： 类注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/clawhub/image/blog/avatar.gif">
<meta property="article:published_time" content="2019-08-06T12:35:25.000Z">
<meta property="article:modified_time" content="2023-09-26T05:51:29.325Z">
<meta property="article:author" content="ClawHub">
<meta property="article:tag" content="java并发容器源码分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/clawhub/image/blog/avatar.gif"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/clawhub/image/blog/favicon-32x32-clawhub.png"><link rel="canonical" href="https://clawhub.github.io/2019/08/06/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90%E4%BA%8C%E3%80%91ConcurrentHashMap%E6%BA%90%E7%A0%81%E7%BF%BB%E8%AF%91%E4%B9%8B%E7%B1%BB%E6%B3%A8%E9%87%8A%E4%B8%8E%E7%BB%BC%E8%BF%B0%E9%83%A8%E5%88%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"GOOBOT5XB8","apiKey":"68084d3bd15b2455050d3030780a5821","indexName":"clawhub-blog-search","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JAVA并发容器源码分析【二】ConcurrentHashMap源码翻译之类注释与综述部分',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-26 13:51:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/clawhub/image/blog/avatar.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">331</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">35</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://uploadbeta.com/api/pictures/random/?key=BingEverydayWallpaperPicture')"><nav id="nav"><span id="blog-info"><a href="/" title="ClawHub的技术分享"><span class="site-name">ClawHub的技术分享</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JAVA并发容器源码分析【二】ConcurrentHashMap源码翻译之类注释与综述部分</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-08-06T12:35:25.000Z" title="发表于 2019-08-06 20:35:25">2019-08-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-26T05:51:29.325Z" title="更新于 2023-09-26 13:51:29">2023-09-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">java并发容器源码分析</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JAVA并发容器源码分析【二】ConcurrentHashMap源码翻译之类注释与综述部分"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>JDK8源码，ConcurrentHashMap的类注释与综述部分：</p>
<h3 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A hash table supporting full concurrency of retrievals and</span></span><br><span class="line"><span class="comment"> * high expected concurrency for updates. This class obeys the</span></span><br><span class="line"><span class="comment"> * same functional specification as &#123;<span class="doctag">@link</span> Hashtable&#125;, and</span></span><br><span class="line"><span class="comment"> * includes versions of methods corresponding to each method of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Hashtable&#125;. However, even though all operations are</span></span><br><span class="line"><span class="comment"> * thread-safe, retrieval operations do &lt;em&gt;not&lt;/em&gt; entail locking,</span></span><br><span class="line"><span class="comment"> * and there is &lt;em&gt;not&lt;/em&gt; any support for locking the entire table</span></span><br><span class="line"><span class="comment"> * in a way that prevents all access.  This class is fully</span></span><br><span class="line"><span class="comment"> * interoperable with &#123;<span class="doctag">@code</span> Hashtable&#125; in programs that rely on its</span></span><br><span class="line"><span class="comment"> * thread safety but not on its synchronization details.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 支持检索的完全并发性和更新的高期望并发性的哈希表。该类遵循与&#123;<span class="doctag">@link</span> Hashtable&#125;相同的功能规范，</span></span><br><span class="line"><span class="comment"> * 并包含与&#123;<span class="doctag">@code</span> Hashtable&#125;的每个方法对应的方法版本。</span></span><br><span class="line"><span class="comment"> * 然而，即使所有操作都是线程安全的，检索操作也不需要锁定，而且不支持以阻止所有访问的方式锁定整个表。</span></span><br><span class="line"><span class="comment"> * 在依赖线程安全而不依赖同步细节的程序中，该类完全可以与&#123;<span class="doctag">@code</span> Hashtable&#125;互操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Retrieval operations (including &#123;<span class="doctag">@code</span> get&#125;) generally do not</span></span><br><span class="line"><span class="comment"> * block, so may overlap with update operations (including &#123;<span class="doctag">@code</span> put&#125;</span></span><br><span class="line"><span class="comment"> * and &#123;<span class="doctag">@code</span> remove&#125;). Retrievals reflect the results of the most</span></span><br><span class="line"><span class="comment"> * recently &lt;em&gt;completed&lt;/em&gt; update operations holding upon their</span></span><br><span class="line"><span class="comment"> * onset. (More formally, an update operation for a given key bears a</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;happens-before&lt;/em&gt; relation with any (non-null) retrieval for</span></span><br><span class="line"><span class="comment"> * that key reporting the updated value.)  For aggregate operations</span></span><br><span class="line"><span class="comment"> * such as &#123;<span class="doctag">@code</span> putAll&#125; and &#123;<span class="doctag">@code</span> clear&#125;, concurrent retrievals may</span></span><br><span class="line"><span class="comment"> * reflect insertion or removal of only some entries.  Similarly,</span></span><br><span class="line"><span class="comment"> * Iterators, Spliterators and Enumerations return elements reflecting the</span></span><br><span class="line"><span class="comment"> * state of the hash table at some point at or since the creation of the</span></span><br><span class="line"><span class="comment"> * iterator/enumeration.  They do &lt;em&gt;not&lt;/em&gt; throw &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * java.util.ConcurrentModificationException ConcurrentModificationException&#125;.</span></span><br><span class="line"><span class="comment"> * However, iterators are designed to be used by only one thread at a time.</span></span><br><span class="line"><span class="comment"> * Bear in mind that the results of aggregate status methods including</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> size&#125;, &#123;<span class="doctag">@code</span> isEmpty&#125;, and &#123;<span class="doctag">@code</span> containsValue&#125; are typically</span></span><br><span class="line"><span class="comment"> * useful only when a map is not undergoing concurrent updates in other threads.</span></span><br><span class="line"><span class="comment"> * Otherwise the results of these methods reflect transient states</span></span><br><span class="line"><span class="comment"> * that may be adequate for monitoring or estimation purposes, but not</span></span><br><span class="line"><span class="comment"> * for program control.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 检索操作(包括&#123;<span class="doctag">@code</span> get&#125;)通常不会阻塞，因此可能与更新操作(包括&#123;<span class="doctag">@code</span> put&#125;和&#123;<span class="doctag">@code</span> remove&#125;)重叠。</span></span><br><span class="line"><span class="comment"> * 检索反映最近完成的更新操作在开始时的结果。(更正式地说，给定键的更新操作与报告更新值的键的任何(非null)检索都具有happens-before关系。)</span></span><br><span class="line"><span class="comment"> * 对于诸如&#123;<span class="doctag">@code</span> putAll&#125;和&#123;<span class="doctag">@code</span> clear&#125;之类的聚合操作，并发检索可能只反映插入或删除某些条目。</span></span><br><span class="line"><span class="comment"> * 类似地，迭代器、Spliterators和枚举返回反映哈希表在迭代器/枚举创建时或创建后的状态的元素。</span></span><br><span class="line"><span class="comment"> * 它们不会抛出&#123;<span class="doctag">@link</span> java.util.ConcurrentModificationException ConcurrentModificationException&#125;。但是，迭代器一次只能被一个线程使用。</span></span><br><span class="line"><span class="comment"> * 请记住，聚合状态方法(包括&#123;<span class="doctag">@code</span> size&#125;、&#123;<span class="doctag">@code</span> isEmpty&#125;和&#123;<span class="doctag">@code</span> containsValue&#125;)的结果通常只有在映射没有在其他线程中进行并发更新时才有用。</span></span><br><span class="line"><span class="comment"> * 否则，这些方法的结果反映的瞬态状态可能足以用于监测或估计目的，但不用于程序控制。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The table is dynamically expanded when there are too many</span></span><br><span class="line"><span class="comment"> * collisions (i.e., keys that have distinct hash codes but fall into</span></span><br><span class="line"><span class="comment"> * the same slot modulo the table size), with the expected average</span></span><br><span class="line"><span class="comment"> * effect of maintaining roughly two bins per mapping (corresponding</span></span><br><span class="line"><span class="comment"> * to a 0.75 load factor threshold for resizing). There may be much</span></span><br><span class="line"><span class="comment"> * variance around this average as mappings are added and removed, but</span></span><br><span class="line"><span class="comment"> * overall, this maintains a commonly accepted time/space tradeoff for</span></span><br><span class="line"><span class="comment"> * hash tables.  However, resizing this or any other kind of hash</span></span><br><span class="line"><span class="comment"> * table may be a relatively slow operation. When possible, it is a</span></span><br><span class="line"><span class="comment"> * good idea to provide a size estimate as an optional &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * initialCapacity&#125; constructor argument. An additional optional</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> loadFactor&#125; constructor argument provides a further means of</span></span><br><span class="line"><span class="comment"> * customizing initial table capacity by specifying the table density</span></span><br><span class="line"><span class="comment"> * to be used in calculating the amount of space to allocate for the</span></span><br><span class="line"><span class="comment"> * given number of elements.  Also, for compatibility with previous</span></span><br><span class="line"><span class="comment"> * versions of this class, constructors may optionally specify an</span></span><br><span class="line"><span class="comment"> * expected &#123;<span class="doctag">@code</span> concurrencyLevel&#125; as an additional hint for</span></span><br><span class="line"><span class="comment"> * internal sizing.  Note that using many keys with exactly the same</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> hashCode()&#125; is a sure way to slow down performance of any</span></span><br><span class="line"><span class="comment"> * hash table. To ameliorate impact, when keys are &#123;<span class="doctag">@link</span> Comparable&#125;,</span></span><br><span class="line"><span class="comment"> * this class may use comparison order among keys to help break ties.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当冲突太多时，表会动态扩展，每个映射维护大约两个桶的平均预期效果(对应于调整大小的0.75负载因子阈值)</span></span><br><span class="line"><span class="comment"> * 随着映射的添加和删除，这个平均值周围可能会有很大的差异，但总的来说，这维护了哈希表的普遍接受的时间/空间权衡。</span></span><br><span class="line"><span class="comment"> * 然而，调整这个或任何其他类型的散列 table可能是一个相对较慢的操作。</span></span><br><span class="line"><span class="comment"> * 如果可能，最好提供一个大小估计作为一个可选的&#123;<span class="doctag">@code</span> initialCapacity&#125;构造函数参数。</span></span><br><span class="line"><span class="comment"> * 另外一个可选的&#123;<span class="doctag">@code</span> loadFactor&#125;构造函数参数提供了定制初始表容量的进一步方法，它指定了用于计算给定元素数量分配的空间量的表密度。</span></span><br><span class="line"><span class="comment"> * 此外，为了与该类的以前版本兼容，构造函数可以选择指定一个预期的&#123;<span class="doctag">@code</span> concurrencyLevel&#125;作为内部分级的额外提示。</span></span><br><span class="line"><span class="comment"> * 注意，使用具有完全相同的&#123;<span class="doctag">@code</span> hashCode()&#125;的许多键肯定会降低任何散列表的性能。</span></span><br><span class="line"><span class="comment"> * 为了改善影响，当键是&#123;<span class="doctag">@link</span> Comparable&#125;时，该类可以使用键之间的比较顺序来帮助断开连接。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A &#123;<span class="doctag">@link</span> Set&#125; projection of a ConcurrentHashMap may be created</span></span><br><span class="line"><span class="comment"> * (using &#123;<span class="doctag">@link</span> #newKeySet()&#125; or &#123;<span class="doctag">@link</span> #newKeySet(int)&#125;), or viewed</span></span><br><span class="line"><span class="comment"> * (using &#123;<span class="doctag">@link</span> #keySet(Object)&#125; when only keys are of interest, and the</span></span><br><span class="line"><span class="comment"> * mapped values are (perhaps transiently) not used or all take the</span></span><br><span class="line"><span class="comment"> * same mapping value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 可以创建ConcurrentHashMap的&#123;<span class="doctag">@link</span> Set&#125;投影(使用&#123;<span class="doctag">@link</span> #newKeySet()&#125;或&#123;<span class="doctag">@link</span> #newKeySet(int)&#125;)，</span></span><br><span class="line"><span class="comment"> * 也可以查看(使用&#123;<span class="doctag">@link</span> #keySet(Object)&#125;，如果只对键感兴趣，并且映射的值(可能暂时)没有使用，或者全部使用相同的映射值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A ConcurrentHashMap can be used as scalable frequency map (a</span></span><br><span class="line"><span class="comment"> * form of histogram or multiset) by using &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * java.util.concurrent.atomic.LongAdder&#125; values and initializing via</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #computeIfAbsent computeIfAbsent&#125;. For example, to add a count</span></span><br><span class="line"><span class="comment"> * to a &#123;<span class="doctag">@code</span> ConcurrentHashMap&lt;String,LongAdder&gt; freqs&#125;, you can use</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> freqs.computeIfAbsent(k -&gt; new LongAdder()).increment();&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ConcurrentHashMap可以用作可伸缩的频率映射（直方图或多集的一种形式）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class and its views and iterators implement all of the</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;optional&lt;/em&gt; methods of the &#123;<span class="doctag">@link</span> Map&#125; and &#123;<span class="doctag">@link</span> Iterator&#125;</span></span><br><span class="line"><span class="comment"> * interfaces.</span></span><br><span class="line"><span class="comment"> *  这个类，视图，迭代器都是实现了Map和Iterator接口。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Like &#123;<span class="doctag">@link</span> Hashtable&#125; but unlike &#123;<span class="doctag">@link</span> HashMap&#125;, this class</span></span><br><span class="line"><span class="comment"> * does &lt;em&gt;not&lt;/em&gt; allow &#123;<span class="doctag">@code</span> null&#125; to be used as a key or value.</span></span><br><span class="line"><span class="comment"> * 这个类不允许null键与null值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;ConcurrentHashMaps support a set of sequential and parallel bulk</span></span><br><span class="line"><span class="comment"> * operations that, unlike most &#123;<span class="doctag">@link</span> Stream&#125; methods, are designed</span></span><br><span class="line"><span class="comment"> * to be safely, and often sensibly, applied even with maps that are</span></span><br><span class="line"><span class="comment"> * being concurrently updated by other threads; for example, when</span></span><br><span class="line"><span class="comment"> * computing a snapshot summary of the values in a shared registry.</span></span><br><span class="line"><span class="comment"> * There are three kinds of operation, each with four forms, accepting</span></span><br><span class="line"><span class="comment"> * functions with Keys, Values, Entries, and (Key, Value) arguments</span></span><br><span class="line"><span class="comment"> * and/or return values. Because the elements of a ConcurrentHashMap</span></span><br><span class="line"><span class="comment"> * are not ordered in any particular way, and may be processed in</span></span><br><span class="line"><span class="comment"> * different orders in different parallel executions, the correctness</span></span><br><span class="line"><span class="comment"> * of supplied functions should not depend on any ordering, or on any</span></span><br><span class="line"><span class="comment"> * other objects or values that may transiently change while</span></span><br><span class="line"><span class="comment"> * computation is in progress; and except for forEach actions, should</span></span><br><span class="line"><span class="comment"> * ideally be side-effect-free. Bulk operations on &#123;<span class="doctag">@link</span> Entry&#125;</span></span><br><span class="line"><span class="comment"> * objects do not support method &#123;<span class="doctag">@code</span> setValue&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ConcurrentHashMaps支持一组顺序的和并行的批量操作，与大多数&#123;<span class="doctag">@link</span> Stream&#125;方法不同，</span></span><br><span class="line"><span class="comment"> * 这些操作的设计是安全的，而且通常是明智的，甚至可以应用于由其他线程并发更新的映射;</span></span><br><span class="line"><span class="comment"> * 例如，在计算共享注册表中值的快照摘要时。有三种操作，每种都有四种形式，接受带有键、值、条目和(键、值)参数和/或返回值的函数。</span></span><br><span class="line"><span class="comment"> * 因为ConcurrentHashMap的元素不是命令在任何特定的方式,并可能在不同的订单处理并行执行的正确性提供功能不应该依赖于任何命令,</span></span><br><span class="line"><span class="comment"> * 或任何其他对象或值可能是暂时性的变化而计算正在进行中;除了每个动作，最好是没有副作用的。</span></span><br><span class="line"><span class="comment"> * 对象上的批量操作不支持方法&#123;<span class="doctag">@code</span> setValue&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; forEach: Perform a given action on each element.</span></span><br><span class="line"><span class="comment"> * A variant form applies a given transformation on each element</span></span><br><span class="line"><span class="comment"> * before performing the action.&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 对每个元素执行给定的操作。变体形式在执行操作之前对每个元素应用给定的转换。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; search: Return the first available non-null result of</span></span><br><span class="line"><span class="comment"> * applying a given function on each element; skipping further</span></span><br><span class="line"><span class="comment"> * search when a result is found.&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 搜索:返回对每个元素应用给定函数的第一个可用的非空结果;找到结果时跳过进一步的搜索。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; reduce: Accumulate each element.  The supplied reduction</span></span><br><span class="line"><span class="comment"> * function cannot rely on ordering (more formally, it should be</span></span><br><span class="line"><span class="comment"> * both associative and commutative).  There are five variants:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 减少:积累每个元素。所提供的约简函数不能依赖于排序(更正式地说，它应该是结合的和交换的)。有五种变体:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; Plain reductions. (There is not a form of this method for</span></span><br><span class="line"><span class="comment"> * (key, value) function arguments since there is no corresponding</span></span><br><span class="line"><span class="comment"> * return type.)&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 普通的减少。(对于(key, value)函数参数没有这种方法的形式，因为没有相应的返回类型。)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; Mapped reductions that accumulate the results of a given</span></span><br><span class="line"><span class="comment"> * function applied to each element.&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将给定函数的结果累积到每个元素上的映射约简。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; Reductions to scalar doubles, longs, and ints, using a</span></span><br><span class="line"><span class="comment"> * given basis value.&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用给定的基值将其缩减为标量双精度、长精度和整数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;These bulk operations accept a &#123;<span class="doctag">@code</span> parallelismThreshold&#125;</span></span><br><span class="line"><span class="comment"> * argument. Methods proceed sequentially if the current map size is</span></span><br><span class="line"><span class="comment"> * estimated to be less than the given threshold. Using a value of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Long.MAX_VALUE&#125; suppresses all parallelism.  Using a value</span></span><br><span class="line"><span class="comment"> * of &#123;<span class="doctag">@code</span> 1&#125; results in maximal parallelism by partitioning into</span></span><br><span class="line"><span class="comment"> * enough subtasks to fully utilize the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * ForkJoinPool#commonPool()&#125; that is used for all parallel</span></span><br><span class="line"><span class="comment"> * computations. Normally, you would initially choose one of these</span></span><br><span class="line"><span class="comment"> * extreme values, and then measure performance of using in-between</span></span><br><span class="line"><span class="comment"> * values that trade off overhead versus throughput.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这些批量操作接受一个&#123;<span class="doctag">@code</span> parallel elismthreshold&#125;参数。如果当前映射大小估计小于给定阈值，则按顺序执行。</span></span><br><span class="line"><span class="comment"> * 使用值&#123;<span class="doctag">@code</span> Long。MAX_VALUE&#125;抑制所有并行。使用&#123;<span class="doctag">@code</span> 1&#125;的值将划分为足够多的子任务，</span></span><br><span class="line"><span class="comment"> * 从而充分利用用于所有并行计算的&#123;<span class="doctag">@link</span> ForkJoinPool#commonPool()&#125;，从而获得最大的并行性。</span></span><br><span class="line"><span class="comment"> * 通常，您首先会选择这些极值中的一个，然后度量使用介于开销和吞吐量之间的值的性能.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The concurrency properties of bulk operations follow</span></span><br><span class="line"><span class="comment"> * from those of ConcurrentHashMap: Any non-null result returned</span></span><br><span class="line"><span class="comment"> * from &#123;<span class="doctag">@code</span> get(key)&#125; and related access methods bears a</span></span><br><span class="line"><span class="comment"> * happens-before relation with the associated insertion or</span></span><br><span class="line"><span class="comment"> * update.  The result of any bulk operation reflects the</span></span><br><span class="line"><span class="comment"> * composition of these per-element relations (but is not</span></span><br><span class="line"><span class="comment"> * necessarily atomic with respect to the map as a whole unless it</span></span><br><span class="line"><span class="comment"> * is somehow known to be quiescent).  Conversely, because keys</span></span><br><span class="line"><span class="comment"> * and values in the map are never null, null serves as a reliable</span></span><br><span class="line"><span class="comment"> * atomic indicator of the current lack of any result.  To</span></span><br><span class="line"><span class="comment"> * maintain this property, null serves as an implicit basis for</span></span><br><span class="line"><span class="comment"> * all non-scalar reduction operations. For the double, long, and</span></span><br><span class="line"><span class="comment"> * int versions, the basis should be one that, when combined with</span></span><br><span class="line"><span class="comment"> * any other value, returns that other value (more formally, it</span></span><br><span class="line"><span class="comment"> * should be the identity element for the reduction). Most common</span></span><br><span class="line"><span class="comment"> * reductions have these properties; for example, computing a sum</span></span><br><span class="line"><span class="comment"> * with basis 0 or a minimum with basis MAX_VALUE.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 批量操作的并发性属性遵循ConcurrentHashMap的并发性属性:</span></span><br><span class="line"><span class="comment"> * 从&#123;<span class="doctag">@code</span> get(key)&#125;和相关的访问方法返回的任何非null结果都与相关的插入或更新保持事前关系。</span></span><br><span class="line"><span class="comment"> * 任何批量操作的结果都反映了这些每个元素之间关系的组成(但对于整个映射来说，并不一定是原子关系，除非知道它是静态的)。</span></span><br><span class="line"><span class="comment"> * 相反，由于映射中的键和值从来都不是null，所以null可以作为当前缺少任何结果的可靠原子指示器。</span></span><br><span class="line"><span class="comment"> * 要维护此属性，null作为所有非标量约简操作的隐式基。</span></span><br><span class="line"><span class="comment"> * 对于double、long和int版本，基应该是与任何其他值组合时返回该其他值的基(更正式地说，它应该是还原的恒等元素)。</span></span><br><span class="line"><span class="comment"> * 大多数常见的约简具有这些性质;例如，计算以0为基底的和或以MAX_VALUE为基底的最小值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Search and transformation functions provided as arguments</span></span><br><span class="line"><span class="comment"> * should similarly return null to indicate the lack of any result</span></span><br><span class="line"><span class="comment"> * (in which case it is not used). In the case of mapped</span></span><br><span class="line"><span class="comment"> * reductions, this also enables transformations to serve as</span></span><br><span class="line"><span class="comment"> * filters, returning null (or, in the case of primitive</span></span><br><span class="line"><span class="comment"> * specializations, the identity basis) if the element should not</span></span><br><span class="line"><span class="comment"> * be combined. You can create compound transformations and</span></span><br><span class="line"><span class="comment"> * filterings by composing them yourself under this &quot;null means</span></span><br><span class="line"><span class="comment"> * there is nothing there now&quot; rule before using them in search or</span></span><br><span class="line"><span class="comment"> * reduce operations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 作为参数提供的搜索和转换函数应该类似地返回null，以指示缺少任何结果(在这种情况下不使用它)。</span></span><br><span class="line"><span class="comment"> * 在映射约简的情况下，这还允许转换充当过滤器，如果元素不应该组合，则返回null(或者，在原始专门化的情况下，返回标识基)。</span></span><br><span class="line"><span class="comment"> * 您可以通过自己在这个null下组合它们来创建复合转换和筛选，这意味着在搜索或reduce操作中使用它们之前没有任何“规则”。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Methods accepting and/or returning Entry arguments maintain</span></span><br><span class="line"><span class="comment"> * key-value associations. They may be useful for example when</span></span><br><span class="line"><span class="comment"> * finding the key for the greatest value. Note that &quot;plain&quot; Entry</span></span><br><span class="line"><span class="comment"> * arguments can be supplied using &#123;<span class="doctag">@code</span> new</span></span><br><span class="line"><span class="comment"> * AbstractMap.SimpleEntry(k,v)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 接受和/或返回条目参数的方法维护键值关联。</span></span><br><span class="line"><span class="comment"> * 例如，当查找值最大的键时，它们可能很有用。</span></span><br><span class="line"><span class="comment"> * 注意，可以使用&#123;<span class="doctag">@code</span> new AbstractMap.SimpleEntry(k,v)&#125;提供“普通”条目参数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Bulk operations may complete abruptly, throwing an</span></span><br><span class="line"><span class="comment"> * exception encountered in the application of a supplied</span></span><br><span class="line"><span class="comment"> * function. Bear in mind when handling such exceptions that other</span></span><br><span class="line"><span class="comment"> * concurrently executing functions could also have thrown</span></span><br><span class="line"><span class="comment"> * exceptions, or would have done so if the first exception had</span></span><br><span class="line"><span class="comment"> * not occurred.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 批量操作可能会突然完成，从而引发在所提供的函数的应用程序中遇到的异常。</span></span><br><span class="line"><span class="comment"> * 在处理此类异常时，请记住，其他并发执行的函数也可能抛出异常,或者，如果第一个异常没有发生，就会这样做。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Speedups for parallel compared to sequential forms are common</span></span><br><span class="line"><span class="comment"> * but not guaranteed.  Parallel operations involving brief functions</span></span><br><span class="line"><span class="comment"> * on small maps may execute more slowly than sequential forms if the</span></span><br><span class="line"><span class="comment"> * underlying work to parallelize the computation is more expensive</span></span><br><span class="line"><span class="comment"> * than the computation itself.  Similarly, parallelization may not</span></span><br><span class="line"><span class="comment"> * lead to much actual parallelism if all processors are busy</span></span><br><span class="line"><span class="comment"> * performing unrelated tasks.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 与顺序形式相比，并行形式的加速比较常见，但不能保证。</span></span><br><span class="line"><span class="comment"> * 如果并行计算的底层工作比计算本身更昂贵，那么涉及小映射上的简短函数的并行操作执行起来可能比顺序形式慢。</span></span><br><span class="line"><span class="comment"> * 类似地，如果所有处理器都忙于执行不相关的任务，并行化可能不会导致太多实际的并行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;All arguments to all task methods must be non-null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所有任务方法的所有参数必须是非空的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class is a member of the</span></span><br><span class="line"><span class="comment"> * &lt;a href=&quot;&#123;<span class="doctag">@docRoot</span>&#125;/../technotes/guides/collections/index.html&quot;&gt;</span></span><br><span class="line"><span class="comment"> * Java Collections Framework&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该类是Java集合框架的成员</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; the type of keys maintained by this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; the type of mapped values</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>###综述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  * Overview:</span><br><span class="line">  *  综述:</span><br><span class="line">  *</span><br><span class="line">  *</span><br><span class="line">  * The primary design goal of this hash table is to maintain</span><br><span class="line">  * concurrent readability (typically method get(), but also</span><br><span class="line">  * iterators and related methods) while minimizing update</span><br><span class="line">  * contention. Secondary goals are to keep space consumption about</span><br><span class="line">  * the same or better than java.util.HashMap, and to support high</span><br><span class="line">  * initial insertion rates on an empty table by many threads.</span><br><span class="line">  *</span><br><span class="line">  * 这个哈希表的主要设计目标是维护并发可读性(通常是方法get()，也包括迭代器和相关方法)，同时最小化更新争用。</span><br><span class="line">  * 次要目标是保持空间消耗与java.util相同或更好。并支持多个线程对空表的高初始插入率。</span><br><span class="line">  *</span><br><span class="line">  * This map usually acts as a binned (bucketed) hash table.  Each</span><br><span class="line">  * key-value mapping is held in a Node.  Most nodes are instances</span><br><span class="line">  * of the basic Node class with hash, key, value, and next</span><br><span class="line">  * fields. However, various subclasses exist: TreeNodes are</span><br><span class="line">  * arranged in balanced trees, not lists.  TreeBins hold the roots</span><br><span class="line">  * of sets of TreeNodes. ForwardingNodes are placed at the heads</span><br><span class="line">  * of bins during resizing. ReservationNodes are used as</span><br><span class="line">  * placeholders while establishing values in computeIfAbsent and</span><br><span class="line">  * related methods.  The types TreeBin, ForwardingNode, and</span><br><span class="line">  * ReservationNode do not hold normal user keys, values, or</span><br><span class="line">  * hashes, and are readily distinguishable during search etc</span><br><span class="line">  * because they have negative hash fields and null key and value</span><br><span class="line">  * fields. (These special nodes are either uncommon or transient,</span><br><span class="line">  * so the impact of carrying around some unused fields is</span><br><span class="line">  * insignificant.)</span><br><span class="line">  *</span><br><span class="line">  * 这个映射通常充当一个桶哈希表。每个键值映射都保存在一个节点中。</span><br><span class="line">  * 大多数节点是具有散列、键、值和next字段的基本节点类的实例。</span><br><span class="line">  * 然而，存在各种子类:树节点被安排在平衡的树中，而不是列表中。</span><br><span class="line">  * TreeBins是拥有根节点的树节点。在调整大小时，ForwardingNodes被放置在箱子的顶部。</span><br><span class="line">  * ReservationNodes用作占位符，同时在computeIfAbsent和相关方法中建立值。</span><br><span class="line">  * TreeBin、forward节点和ReservationNode类型不包含普通的用户键、值或散列，</span><br><span class="line">  * 在搜索过程中很容易区分，因为它们具有负散列字段和空键和值字段。</span><br><span class="line">  * (这些特殊节点不是不常见就是短暂的，因此携带一些未使用的字段的影响是微不足道的。)</span><br><span class="line">  *</span><br><span class="line">  * The table is lazily initialized to a power-of-two size upon the</span><br><span class="line">  * first insertion.  Each bin in the table normally contains a</span><br><span class="line">  * list of Nodes (most often, the list has only zero or one Node).</span><br><span class="line">  * Table accesses require volatile/atomic reads, writes, and</span><br><span class="line">  * CASes.  Because there is no other way to arrange this without</span><br><span class="line">  * adding further indirections, we use intrinsics</span><br><span class="line">  * (sun.misc.Unsafe) operations.</span><br><span class="line">  *</span><br><span class="line">  * 第一次插入时，该表被惰性地初始化为2的幂大小。表中的每个桶通常包含一个节点列表(大多数情况下，列表只有0个或一个节点)。</span><br><span class="line">  * 表访问需要volatile/atomic读写和CASes。</span><br><span class="line">  * 因为没有其他方法可以在不添加进一步间接的情况下安排此操作，</span><br><span class="line">  * 所以我们使用了(sun.misc.Unsafe)操作。</span><br><span class="line">  *</span><br><span class="line">  * We use the top (sign) bit of Node hash fields for control</span><br><span class="line">  * purposes -- it is available anyway because of addressing</span><br><span class="line">  * constraints.  Nodes with negative hash fields are specially</span><br><span class="line">  * handled or ignored in map methods.</span><br><span class="line">  *</span><br><span class="line">  * 我们使用节点哈希字段的顶部(符号)位进行控制 --无论如何，它都是可用的，因为要处理约束。</span><br><span class="line">  * 在map方法中，具有负哈希字段的节点被特殊处理或忽略。</span><br><span class="line">  *</span><br><span class="line">  * Insertion (via put or its variants) of the first node in an</span><br><span class="line">  * empty bin is performed by just CASing it to the bin.  This is</span><br><span class="line">  * by far the most common case for put operations under most</span><br><span class="line">  * key/hash distributions.  Other update operations (insert,</span><br><span class="line">  * delete, and replace) require locks.  We do not want to waste</span><br><span class="line">  * the space required to associate a distinct lock object with</span><br><span class="line">  * each bin, so instead use the first node of a bin list itself as</span><br><span class="line">  * a lock. Locking support for these locks relies on builtin</span><br><span class="line">  * &quot;synchronized&quot; monitors.</span><br><span class="line">  * 将第一个节点插入到空容器中，只需通过CAS将其装箱即可。</span><br><span class="line">  * 到目前为止，这是大多数键/散列分布下put操作最常见的情况。</span><br><span class="line">  * 一些更新操作需要锁。我们不想浪费将一个不同的锁对象与每个bin关联所需的空间，所以应该使用bin列表本身的第一个节点作为锁。</span><br><span class="line">  * 对这些锁的锁定支持依赖于内置的“synchronized”监视器。</span><br><span class="line">  *</span><br><span class="line">  * Using the first node of a list as a lock does not by itself</span><br><span class="line">  * suffice though: When a node is locked, any update must first</span><br><span class="line">  * validate that it is still the first node after locking it, and</span><br><span class="line">  * retry if not. Because new nodes are always appended to lists,</span><br><span class="line">  * once a node is first in a bin, it remains first until deleted</span><br><span class="line">  * or the bin becomes invalidated (upon resizing).</span><br><span class="line">  *</span><br><span class="line">  * 使用列表的第一个节点作为锁本身还不够:当一个节点被锁定时，任何更新必须首先验证它仍然是锁定后的第一个节点，如果不是，则重试。</span><br><span class="line">  * 因为新节点总是被附加到列表中，一旦一个节点在一个bin中是第一个节点，它就会保持在第一个，直到删除或bin失效(调整大小后)。</span><br><span class="line">  *</span><br><span class="line">  * The main disadvantage of per-bin locks is that other update</span><br><span class="line">  * operations on other nodes in a bin list protected by the same</span><br><span class="line">  * lock can stall, for example when user equals() or mapping</span><br><span class="line">  * functions take a long time.  However, statistically, under</span><br><span class="line">  * random hash codes, this is not a common problem.  Ideally, the</span><br><span class="line">  * frequency of nodes in bins follows a Poisson distribution</span><br><span class="line">  * (http://en.wikipedia.org/wiki/Poisson_distribution) with a</span><br><span class="line">  * parameter of about 0.5 on average, given the resizing threshold</span><br><span class="line">  * of 0.75, although with a large variance because of resizing</span><br><span class="line">  * granularity. Ignoring variance, the expected occurrences of</span><br><span class="line">  * list size k are (exp(-0.5) * pow(0.5, k) / factorial(k)). The</span><br><span class="line">  * first values are:</span><br><span class="line">  *</span><br><span class="line">  * 0:    0.60653066</span><br><span class="line">  * 1:    0.30326533</span><br><span class="line">  * 2:    0.07581633</span><br><span class="line">  * 3:    0.01263606</span><br><span class="line">  * 4:    0.00157952</span><br><span class="line">  * 5:    0.00015795</span><br><span class="line">  * 6:    0.00001316</span><br><span class="line">  * 7:    0.00000094</span><br><span class="line">  * 8:    0.00000006</span><br><span class="line">  * more: less than 1 in ten million</span><br><span class="line">  *</span><br><span class="line">  * per-bin锁的主要缺点是，受同一锁保护的bin列表中的其他节点上的其他更新操作可能会停止，例如当user equals()或映射函数花费很长时间时。</span><br><span class="line">  * 然而，统计上，在随机哈希码下，这不是一个常见的问题。理想情况下，在给定调整大小阈值为0.75的情况下，</span><br><span class="line">  * 箱中节点的频率遵循泊松分布(Poisson distribution)，其参数平均约为0.5，尽管由于调整粒度而存在较大的方差。</span><br><span class="line">  * 忽略方差，列表大小k的预期出现次数为(exp(-0.5) * pow(0.5, k) / factorial(k))。</span><br><span class="line">  * 第一个值是：</span><br><span class="line">  * 0:    0.60653066</span><br><span class="line">  * 1:    0.30326533</span><br><span class="line">  * 2:    0.07581633</span><br><span class="line">  * 3:    0.01263606</span><br><span class="line">  * 4:    0.00157952</span><br><span class="line">  * 5:    0.00015795</span><br><span class="line">  * 6:    0.00001316</span><br><span class="line">  * 7:    0.00000094</span><br><span class="line">  * 8:    0.00000006</span><br><span class="line">  * more: 少于千分之一</span><br><span class="line">  *</span><br><span class="line">  * Lock contention probability for two threads accessing distinct</span><br><span class="line">  * elements is roughly 1 / (8 * #elements) under random hashes.</span><br><span class="line">  * 在随机散列下，两个线程访问不同元素的锁争用概率大约为1 /(8 * #elements)。</span><br><span class="line">  *</span><br><span class="line">  * Actual hash code distributions encountered in practice</span><br><span class="line">  * sometimes deviate significantly from uniform randomness.  This</span><br><span class="line">  * includes the case when N &gt; (1&lt;&lt;30), so some keys MUST collide.</span><br><span class="line">  * Similarly for dumb or hostile usages in which multiple keys are</span><br><span class="line">  * designed to have identical hash codes or ones that differs only</span><br><span class="line">  * in masked-out high bits. So we use a secondary strategy that</span><br><span class="line">  * applies when the number of nodes in a bin exceeds a</span><br><span class="line">  * threshold. These TreeBins use a balanced tree to hold nodes (a</span><br><span class="line">  * specialized form of red-black trees), bounding search time to</span><br><span class="line">  * O(log N).  Each search step in a TreeBin is at least twice as</span><br><span class="line">  * slow as in a regular list, but given that N cannot exceed</span><br><span class="line">  * (1&lt;&lt;64) (before running out of addresses) this bounds search</span><br><span class="line">  * steps, lock hold times, etc, to reasonable constants (roughly</span><br><span class="line">  * 100 nodes inspected per operation worst case) so long as keys</span><br><span class="line">  * are Comparable (which is very common -- String, Long, etc).</span><br><span class="line">  * TreeBin nodes (TreeNodes) also maintain the same &quot;next&quot;</span><br><span class="line">  * traversal pointers as regular nodes, so can be traversed in</span><br><span class="line">  * iterators in the same way.</span><br><span class="line">  *</span><br><span class="line">  * 实际的哈希码分布在实践中有时会明显偏离均匀随机性。这包括当N &gt;(1&lt;&lt;30)时，因此一些键必须碰撞。</span><br><span class="line">  * 类似地，在一些愚蠢或恶意的用法中，多个键被设计为具有相同的哈希码，或者只有在屏蔽的高位上不同的哈希码。</span><br><span class="line">  * 因此，当一个bin中的节点数量超过阈值时，我们使用一个辅助策略。</span><br><span class="line">  * 这些TreeBins使用一个平衡树来保存节点(红黑树的一种特殊形式)，将搜索时间限制到O(log N)。</span><br><span class="line">  * 每个搜索一步TreeBin至少两倍慢在一个常规列表,但是鉴于N不能超过(1 &lt; &lt; 64)（在地址用完之前）这个界限搜索步骤，锁定持有时间，等,</span><br><span class="line">  * 合理的常量(大约100节点检查每个操作最坏的情况)只要键具有可比性(这是很常见的,String, Long,等等)。</span><br><span class="line">  * TreeBin节点(TreeNodes)也像普通节点一样维护相同的“next”遍历指针，因此可以以相同的方式在迭代器中遍历。</span><br><span class="line">  *</span><br><span class="line">  * The table is resized when occupancy exceeds a percentage</span><br><span class="line">  * threshold (nominally, 0.75, but see below).  Any thread</span><br><span class="line">  * noticing an overfull bin may assist in resizing after the</span><br><span class="line">  * initiating thread allocates and sets up the replacement array.</span><br><span class="line">  * However, rather than stalling, these other threads may proceed</span><br><span class="line">  * with insertions etc.  The use of TreeBins shields us from the</span><br><span class="line">  * worst case effects of overfilling while resizes are in</span><br><span class="line">  * progress.  Resizing proceeds by transferring bins, one by one,</span><br><span class="line">  * from the table to the next table. However, threads claim small</span><br><span class="line">  * blocks of indices to transfer (via field transferIndex) before</span><br><span class="line">  * doing so, reducing contention.  A generation stamp in field</span><br><span class="line">  * sizeCtl ensures that resizings do not overlap. Because we are</span><br><span class="line">  * using power-of-two expansion, the elements from each bin must</span><br><span class="line">  * either stay at same index, or move with a power of two</span><br><span class="line">  * offset. We eliminate unnecessary node creation by catching</span><br><span class="line">  * cases where old nodes can be reused because their next fields</span><br><span class="line">  * won&#x27;t change.  On average, only about one-sixth of them need</span><br><span class="line">  * cloning when a table doubles. The nodes they replace will be</span><br><span class="line">  * garbage collectable as soon as they are no longer referenced by</span><br><span class="line">  * any reader thread that may be in the midst of concurrently</span><br><span class="line">  * traversing table.  Upon transfer, the old table bin contains</span><br><span class="line">  * only a special forwarding node (with hash field &quot;MOVED&quot;) that</span><br><span class="line">  * contains the next table as its key. On encountering a</span><br><span class="line">  * forwarding node, access and update operations restart, using</span><br><span class="line">  * the new table.</span><br><span class="line">  *</span><br><span class="line">  * 当占有率超过百分比阈值(通常为0.75，但看情况)时，将调整表的大小。</span><br><span class="line">  * 任何线程注意到一个过满的bin都可以在初始化线程分配并设置替换数组之后帮助调整大小。</span><br><span class="line">  * 但是，这些其他线程可能会继续执行插入等操作，而不是停止。</span><br><span class="line">  * TreeBins的使用保护了我们从最坏的情况下，过量填充的影响，而调整的过程中。</span><br><span class="line">  * 调整大小的方法是将箱子一个一个地从表转移到下一个表。</span><br><span class="line">  * 然而，线程在这样做之前声明要传输一小块索引(通过字段transferIndex)，从而减少争用。</span><br><span class="line">  * 字段sizeCtl中的生成戳记确保大小调整不会重叠。</span><br><span class="line">  * 因为我们使用的是2的幂展开，所以每个bin中的元素必须保持相同的索引，或者以2的幂偏移量移动。</span><br><span class="line">  * 我们通过捕获可以重用旧节点的情况来消除不必要的节点创建，因为它们的下一个字段不会更改。</span><br><span class="line">  * 平均而言，当表翻倍时，只有大约六分之一的表需要克隆。</span><br><span class="line">  * 它们替换的节点一旦不再被并发遍历表中的任何读线程引用，就会成为垃圾收集节点。</span><br><span class="line">  * 在传输时，旧表bin只包含一个特殊的转发节点(散列字段“MOVED”)，该节点包含下一个表作为键。</span><br><span class="line">  * 遇到转发节点时，使用新表重新启动访问和更新操作。</span><br><span class="line">  *</span><br><span class="line">  *</span><br><span class="line">  * Each bin transfer requires its bin lock, which can stall</span><br><span class="line">  * waiting for locks while resizing. However, because other</span><br><span class="line">  * threads can join in and help resize rather than contend for</span><br><span class="line">  * locks, average aggregate waits become shorter as resizing</span><br><span class="line">  * progresses.  The transfer operation must also ensure that all</span><br><span class="line">  * accessible bins in both the old and new table are usable by any</span><br><span class="line">  * traversal.  This is arranged in part by proceeding from the</span><br><span class="line">  * last bin (table.length - 1) up towards the first.  Upon seeing</span><br><span class="line">  * a forwarding node, traversals (see class Traverser) arrange to</span><br><span class="line">  * move to the new table without revisiting nodes.  To ensure that</span><br><span class="line">  * no intervening nodes are skipped even when moved out of order,</span><br><span class="line">  * a stack (see class TableStack) is created on first encounter of</span><br><span class="line">  * a forwarding node during a traversal, to maintain its place if</span><br><span class="line">  * later processing the current table. The need for these</span><br><span class="line">  * save/restore mechanics is relatively rare, but when one</span><br><span class="line">  * forwarding node is encountered, typically many more will be.</span><br><span class="line">  * So Traversers use a simple caching scheme to avoid creating so</span><br><span class="line">  * many new TableStack nodes. (Thanks to Peter Levart for</span><br><span class="line">  * suggesting use of a stack here.)</span><br><span class="line">  *</span><br><span class="line">  * 每个bin传输都需要它的bin锁，它可以在调整大小时等待锁定。</span><br><span class="line">  * 但是，由于其他线程可以加入并帮助调整大小，而不是争用锁，所以随着调整大小的进行，平均聚合等待时间会变得更短。</span><br><span class="line">  * 传输操作还必须确保旧表和新表中所有可访问的箱子都可用于任何遍历。</span><br><span class="line">  * 这部分是通过从最后一个bin(table.length - 1)向上到第一个。</span><br><span class="line">  * 当看到一个转发节点时，遍历(参见类遍历器)会安排移动到新表，而不需要重新访问节点。</span><br><span class="line">  * 为了确保即使在无序移动时也不会跳过中间节点，在遍历过程中第一次遇到转发节点时会创建一个堆栈(请参见类TableStack)，</span><br><span class="line">  * 以便在以后处理当前表时维护其位置。对这些保存/恢复机制的需求相对较少，但当遇到一个转发节点时，通常会遇到更多。</span><br><span class="line">  * 因此遍历器使用一个简单的缓存方案来避免创建如此多的新表栈节点。(感谢Peter Levart建议在这里使用堆栈。)</span><br><span class="line">  *</span><br><span class="line">  *</span><br><span class="line">  * The traversal scheme also applies to partial traversals of</span><br><span class="line">  * ranges of bins (via an alternate Traverser constructor)</span><br><span class="line">  * to support partitioned aggregate operations.  Also, read-only</span><br><span class="line">  * operations give up if ever forwarded to a null table, which</span><br><span class="line">  * provides support for shutdown-style clearing, which is also not</span><br><span class="line">  * currently implemented.</span><br><span class="line">  *</span><br><span class="line">  * 遍历方案还适用于桶范围的部分遍历(通过另一个遍历构造函数)，以支持分区的聚合操作。</span><br><span class="line">  * 此外，如果将只读操作转发到空表，则将放弃只读操作，空表提供了对关闭样式清除的支持，而关闭样式清除目前也没有实现。</span><br><span class="line">  *</span><br><span class="line">  * Lazy table initialization minimizes footprint until first use,</span><br><span class="line">  * and also avoids resizings when the first operation is from a</span><br><span class="line">  * putAll, constructor with map argument, or deserialization.</span><br><span class="line">  * These cases attempt to override the initial capacity settings,</span><br><span class="line">  * but harmlessly fail to take effect in cases of races.</span><br><span class="line">  *</span><br><span class="line">  * 延迟表初始化在第一次使用之前将占用的空间最小化，并且当第一个操作来自putAll、</span><br><span class="line">  * 带有map参数的构造函数或反序列化时，还可以避免调整大小。</span><br><span class="line">  * 这些情况试图覆盖初始容量设置，但在种族的情况下没有造成伤害。</span><br><span class="line">  *</span><br><span class="line">  * The element count is maintained using a specialization of</span><br><span class="line">  * LongAdder. We need to incorporate a specialization rather than</span><br><span class="line">  * just use a LongAdder in order to access implicit</span><br><span class="line">  * contention-sensing that leads to creation of multiple</span><br><span class="line">  * CounterCells.  The counter mechanics avoid contention on</span><br><span class="line">  * updates but can encounter cache thrashing if read too</span><br><span class="line">  * frequently during concurrent access. To avoid reading so often,</span><br><span class="line">  * resizing under contention is attempted only upon adding to a</span><br><span class="line">  * bin already holding two or more nodes. Under uniform hash</span><br><span class="line">  * distributions, the probability of this occurring at threshold</span><br><span class="line">  * is around 13%, meaning that only about 1 in 8 puts check</span><br><span class="line">  * threshold (and after resizing, many fewer do so).</span><br><span class="line">  *</span><br><span class="line">  * 元素计数使用LongAdder的专门化来维护。为了隐式访问，我们需要合并专门化，</span><br><span class="line">  * 而不是仅仅使用LongAdder竞争感应，导致多个对抗细胞的产生。</span><br><span class="line">  * 计数器机制可以避免更新上的争用，但是如果在并发访问期间读得太频繁，可能会遇到缓存抖动。</span><br><span class="line">  * 为了避免频繁读取，仅在添加到已经包含两个或多个节点的bin时才尝试在争用下调整大小。</span><br><span class="line">  * 在均匀哈希分布下，这种情况发生在阈值处的概率约为13%，这意味着只有大约八分之一的人设置了检查阈值(调整大小后，这样做的人更少)。</span><br><span class="line">  *</span><br><span class="line">  * TreeBins use a special form of comparison for search and</span><br><span class="line">  * related operations (which is the main reason we cannot use</span><br><span class="line">  * existing collections such as TreeMaps). TreeBins contain</span><br><span class="line">  * Comparable elements, but may contain others, as well as</span><br><span class="line">  * elements that are Comparable but not necessarily Comparable for</span><br><span class="line">  * the same T, so we cannot invoke compareTo among them. To handle</span><br><span class="line">  * this, the tree is ordered primarily by hash value, then by</span><br><span class="line">  * Comparable.compareTo order if applicable.  On lookup at a node,</span><br><span class="line">  * if elements are not comparable or compare as 0 then both left</span><br><span class="line">  * and right children may need to be searched in the case of tied</span><br><span class="line">  * hash values. (This corresponds to the full list search that</span><br><span class="line">  * would be necessary if all elements were non-Comparable and had</span><br><span class="line">  * tied hashes.) On insertion, to keep a total ordering (or as</span><br><span class="line">  * close as is required here) across rebalancings, we compare</span><br><span class="line">  * classes and identityHashCodes as tie-breakers. The red-black</span><br><span class="line">  * balancing code is updated from pre-jdk-collections</span><br><span class="line">  * (http://gee.cs.oswego.edu/dl/classes/collections/RBCell.java)</span><br><span class="line">  * based in turn on Cormen, Leiserson, and Rivest &quot;Introduction to</span><br><span class="line">  * Algorithms&quot; (CLR).</span><br><span class="line">  *</span><br><span class="line">  * TreeBins使用一种特殊的比较形式进行搜索和相关操作(这是我们不能使用现有集合(如TreeMaps)的主要原因)。</span><br><span class="line">  * TreeBins包含可比较的元素，但也可能包含其他元素，以及对相同的T具有可比性但不一定具有可比性的元素，因此我们不能在它们之间调用compareTo。</span><br><span class="line">  * 为了处理这个问题，树的顺序主要是按散列值排序，然后按Comparable.compareTo 排序，如果适用的话。</span><br><span class="line">  * 在节点查找时，如果元素不可比较或比较为0，那么在绑定哈希值的情况下，可能需要搜索左子元素和右子元素。</span><br><span class="line">  * (这对应于完整的列表搜索，如果所有元素都是不可比较的，并且已经绑定了散列，那么这将是必要的。)</span><br><span class="line">  * 在插入时，为了保持跨重新平衡的总顺序(或尽可能接近这里的要求)，我们将类和identityHashCodes作为连接符进行比较。</span><br><span class="line">  * 红黑平衡代码是根据Cormen、Leiserson和Rivest的“算法介绍”(CLR)，从pre-jdk-collections更新的。</span><br><span class="line">  *</span><br><span class="line">  *</span><br><span class="line">  * TreeBins also require an additional locking mechanism.  While</span><br><span class="line">  * list traversal is always possible by readers even during</span><br><span class="line">  * updates, tree traversal is not, mainly because of tree-rotations</span><br><span class="line">  * that may change the root node and/or its linkages.  TreeBins</span><br><span class="line">  * include a simple read-write lock mechanism parasitic on the</span><br><span class="line">  * main bin-synchronization strategy: Structural adjustments</span><br><span class="line">  * associated with an insertion or removal are already bin-locked</span><br><span class="line">  * (and so cannot conflict with other writers) but must wait for</span><br><span class="line">  * ongoing readers to finish. Since there can be only one such</span><br><span class="line">  * waiter, we use a simple scheme using a single &quot;waiter&quot; field to</span><br><span class="line">  * block writers.  However, readers need never block.  If the root</span><br><span class="line">  * lock is held, they proceed along the slow traversal path (via</span><br><span class="line">  * next-pointers) until the lock becomes available or the list is</span><br><span class="line">  * exhausted, whichever comes first. These cases are not fast, but</span><br><span class="line">  * maximize aggregate expected throughput.</span><br><span class="line">  *</span><br><span class="line">  * TreeBins还需要一个额外的锁定机制。虽然即使在更新期间，读取器也始终可以执行列表遍历，</span><br><span class="line">  * 但是树遍历不行，这主要是因为树的旋转可能会更改根节点和/或其链接。</span><br><span class="line">  * TreeBins包含一个简单的读写锁机制，寄生在主要的bin同步策略上:</span><br><span class="line">  * 与插入或删除相关的结构调整已经锁定(因此不能与其他作者发生冲突)，但必须等待正在进行的读者完成。</span><br><span class="line">  * 由于只能有一个这样的waiter，所以我们使用一个简单的方案，使用一个“waiter”字段来阻止编写器。</span><br><span class="line">  * 然而，读者永远不需要阻塞。如果持有根锁，它们将沿着缓慢的遍历路径(通过下一个指针)进行，直到锁可用或列表耗尽，无论哪个先出现。</span><br><span class="line">  * 这些情况并不快，但是可以最大限度地提高总预期吞吐量。</span><br><span class="line">  *</span><br><span class="line">  * Maintaining API and serialization compatibility with previous</span><br><span class="line">  * versions of this class introduces several oddities. Mainly: We</span><br><span class="line">  * leave untouched but unused constructor arguments refering to</span><br><span class="line">  * concurrencyLevel. We accept a loadFactor constructor argument,</span><br><span class="line">  * but apply it only to initial table capacity (which is the only</span><br><span class="line">  * time that we can guarantee to honor it.) We also declare an</span><br><span class="line">  * unused &quot;Segment&quot; class that is instantiated in minimal form</span><br><span class="line">  * only when serializing.</span><br><span class="line">  *</span><br><span class="line">  * 维护这个类以前版本的API和序列化兼容性会带来一些奇怪的现象。主要：</span><br><span class="line">  * 我们保留未修改但未使用的构造函数参数来引用concurrencyLevel。</span><br><span class="line">  * 我们接受loadFactor构造函数参数，但只将其应用于初始表容量(这是我们能够保证遵守它的惟一时间)。</span><br><span class="line">  * 我们还声明了一个未使用的“Segment”类，该类仅在序列化时以最小形式实例化。</span><br><span class="line">  *</span><br><span class="line">  * Also, solely for compatibility with previous versions of this</span><br><span class="line">  * class, it extends AbstractMap, even though all of its methods</span><br><span class="line">  * are overridden, so it is just useless baggage.</span><br><span class="line">  *</span><br><span class="line">  * 而且，仅为了与该类的以前版本兼容，它扩展了AbstractMap，即使覆盖了它的所有方法，所以它只是无用的包袱。</span><br><span class="line">  *</span><br><span class="line">  * This file is organized to make things a little easier to follow</span><br><span class="line">  * while reading than they might otherwise: First the main static</span><br><span class="line">  * declarations and utilities, then fields, then main public</span><br><span class="line">  * methods (with a few factorings of multiple public methods into</span><br><span class="line">  * internal ones), then sizing methods, trees, traversers, and</span><br><span class="line">  * bulk operations.</span><br><span class="line">  *</span><br><span class="line">  * 这个文件的组织是为了让阅读的时候更容易理解:</span><br><span class="line">  * 首先是主静态声明和实用程序，然后是字段，然后是主公共方法(将多个公共方法分解为内部方法)，然后是调整方法大小、树、遍历器和批量操作。</span><br><span class="line">  */</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://clawhub.github.io">ClawHub</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://clawhub.github.io/2019/08/06/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90%E4%BA%8C%E3%80%91ConcurrentHashMap%E6%BA%90%E7%A0%81%E7%BF%BB%E8%AF%91%E4%B9%8B%E7%B1%BB%E6%B3%A8%E9%87%8A%E4%B8%8E%E7%BB%BC%E8%BF%B0%E9%83%A8%E5%88%86/">https://clawhub.github.io/2019/08/06/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90%E4%BA%8C%E3%80%91ConcurrentHashMap%E6%BA%90%E7%A0%81%E7%BF%BB%E8%AF%91%E4%B9%8B%E7%B1%BB%E6%B3%A8%E9%87%8A%E4%B8%8E%E7%BB%BC%E8%BF%B0%E9%83%A8%E5%88%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://clawhub.github.io" target="_blank">ClawHub的技术分享</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">java并发容器源码分析</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/clawhub/image/blog/avatar.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/08/06/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90%E5%9B%9B%E3%80%91LinkedBlockingQueue%E4%BB%8B%E7%BB%8D/" title="JAVA并发容器源码分析【四】LinkedBlockingQueue介绍"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JAVA并发容器源码分析【四】LinkedBlockingQueue介绍</div></div></a></div><div class="next-post pull-right"><a href="/2019/08/06/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90%E4%B8%80%E3%80%91%E5%BC%80%E7%AF%87/" title="JAVA并发容器源码分析【一】开篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JAVA并发容器源码分析【一】开篇</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/08/06/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90%E4%B8%80%E3%80%91%E5%BC%80%E7%AF%87/" title="JAVA并发容器源码分析【一】开篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-08-06</div><div class="title">JAVA并发容器源码分析【一】开篇</div></div></a></div><div><a href="/2019/08/06/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90%E4%B8%89%E3%80%91CopyOnWriteArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="JAVA并发容器源码分析【三】CopyOnWriteArrayList源码分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-08-06</div><div class="title">JAVA并发容器源码分析【三】CopyOnWriteArrayList源码分析</div></div></a></div><div><a href="/2019/08/06/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90%E4%B8%89%E3%80%91CopyOnWriteArrayList%E6%BA%90%E7%A0%81%E7%BF%BB%E8%AF%91/" title="JAVA并发容器源码分析【三】CopyOnWriteArrayList源码翻译"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-08-06</div><div class="title">JAVA并发容器源码分析【三】CopyOnWriteArrayList源码翻译</div></div></a></div><div><a href="/2019/08/06/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90%E4%BA%8C%E3%80%91ConcurrentHashMap%E5%88%86%E6%9E%90%E4%B9%8BCAS%E5%8E%9F%E7%90%86/" title="JAVA并发容器源码分析【二】ConcurrentHashMap分析之CAS原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-08-06</div><div class="title">JAVA并发容器源码分析【二】ConcurrentHashMap分析之CAS原理</div></div></a></div><div><a href="/2019/08/06/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90%E4%BA%8C%E3%80%91ConcurrentHashMap%E5%88%86%E6%9E%90%E4%B9%8Bget/" title="JAVA并发容器源码分析【二】ConcurrentHashMap分析之get"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-08-06</div><div class="title">JAVA并发容器源码分析【二】ConcurrentHashMap分析之get</div></div></a></div><div><a href="/2019/08/06/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90%E4%BA%8C%E3%80%91ConcurrentHashMap%E5%88%86%E6%9E%90%E4%B9%8BputVal/" title="JAVA并发容器源码分析【二】ConcurrentHashMap分析之putVal"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-08-06</div><div class="title">JAVA并发容器源码分析【二】ConcurrentHashMap分析之putVal</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/clawhub/image/blog/avatar.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ClawHub</div><div class="author-info__description">ClawHub的技术分享，记录学习中的点点滴滴！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">331</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">35</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/clawhub" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:clawhub@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%B3%A8%E9%87%8A"><span class="toc-text">类注释</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/09/20/%E9%9A%8F%E7%AC%94/2023%E9%87%8D%E6%95%B4%E5%BE%85%E5%8F%91/" title="2023重整待发"><img src="https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/top/19/11/27/04cde2146d3d116bc3a2cea0a22d8138.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2023重整待发"/></a><div class="content"><a class="title" href="/2023/09/20/%E9%9A%8F%E7%AC%94/2023%E9%87%8D%E6%95%B4%E5%BE%85%E5%8F%91/" title="2023重整待发">2023重整待发</a><time datetime="2023-09-20T14:02:59.000Z" title="发表于 2023-09-20 22:02:59">2023-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E9%98%BF%E9%87%8CAPI%E7%BD%91%E5%85%B3%E4%B8%8EDubbo%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8/" title="阿里API网关与Dubbo泛化调用"><img src="https://cdn.jsdelivr.net/gh/ClawHub/image/image/photo-1677746792119-d8f8ee8e77f5%3Fcrop%3Dentropy%26cs%3Dtinysrgb%26fit%3Dcrop%26fm%3Djpg%26h%3D900%26ixid%3DMnwxfDB8MXxyYW5kb218MHxjb2xsZWN0aW9uaWR8fHx8fHx8MTY5NTc5ODc0Nw%26ixlib%3Drb-4.0.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="阿里API网关与Dubbo泛化调用"/></a><div class="content"><a class="title" href="/2022/05/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E9%98%BF%E9%87%8CAPI%E7%BD%91%E5%85%B3%E4%B8%8EDubbo%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8/" title="阿里API网关与Dubbo泛化调用">阿里API网关与Dubbo泛化调用</a><time datetime="2022-05-21T13:45:42.000Z" title="发表于 2022-05-21 21:45:42">2022-05-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/02/21/%E8%B5%84%E6%BA%90%E6%90%9C%E9%9B%86/%E6%9E%B6%E6%9E%84%E6%96%87%E7%AB%A0%E6%90%9C%E9%9B%86/" title="架构文章搜集"><img src="https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/top/19/11/27/bfff056d1e8ca0e9ba91286143e7989d.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="架构文章搜集"/></a><div class="content"><a class="title" href="/2020/02/21/%E8%B5%84%E6%BA%90%E6%90%9C%E9%9B%86/%E6%9E%B6%E6%9E%84%E6%96%87%E7%AB%A0%E6%90%9C%E9%9B%86/" title="架构文章搜集">架构文章搜集</a><time datetime="2020-02-21T03:20:59.000Z" title="发表于 2020-02-21 11:20:59">2020-02-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/01/20/%E9%9A%8F%E7%AC%94/%E9%98%BF%E9%87%8CCCO%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95%E7%9A%84%E6%80%9D%E8%80%83/" title="阿里CCO项目组面试的思考"><img src="https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/top/19/11/27/04cde2146d3d116bc3a2cea0a22d8138.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="阿里CCO项目组面试的思考"/></a><div class="content"><a class="title" href="/2020/01/20/%E9%9A%8F%E7%AC%94/%E9%98%BF%E9%87%8CCCO%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95%E7%9A%84%E6%80%9D%E8%80%83/" title="阿里CCO项目组面试的思考">阿里CCO项目组面试的思考</a><time datetime="2020-01-20T14:02:59.000Z" title="发表于 2020-01-20 22:02:59">2020-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/01/19/%E9%9D%A2%E8%AF%95/%E9%98%BF%E9%87%8CJava%E5%90%8E%E7%AB%AF%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/" title="阿里Java后端在线笔试题及答案"><img src="https://cdn.jsdelivr.net/gh/clawhub/image/diffuser/top/19/11/27/36d28ae9e40c127e700c673778a902e0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="阿里Java后端在线笔试题及答案"/></a><div class="content"><a class="title" href="/2020/01/19/%E9%9D%A2%E8%AF%95/%E9%98%BF%E9%87%8CJava%E5%90%8E%E7%AB%AF%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/" title="阿里Java后端在线笔试题及答案">阿里Java后端在线笔试题及答案</a><time datetime="2020-01-19T03:33:59.000Z" title="发表于 2020-01-19 11:33:59">2020-01-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2023 By ClawHub</div><div class="footer_custom_text">好好学习 天天向上</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div></body></html>